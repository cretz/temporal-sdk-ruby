# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `grpc` gem.
# Please instead update this file by running `bin/tapioca gem grpc`.


# GRPC is the general RPC module
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#16
module GRPC
  extend ::GRPC::DefaultLogger

  private

  def postfork_child; end
  def postfork_parent; end
  def prefork; end

  class << self
    # source://grpc//src/ruby/lib/grpc/logconfig.rb#17
    def logger=(logger_obj); end

    def postfork_child; end
    def postfork_parent; end
    def prefork; end
  end
end

# GRPC status code corresponding to status ABORTED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#219
class GRPC::Aborted < ::GRPC::BadStatus
  # @return [Aborted] a new instance of Aborted
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#220
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# The ActiveCall class provides simple methods for sending marshallable
# data to a call
#
# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#42
class GRPC::ActiveCall
  include ::GRPC::Core::TimeConsts
  include ::GRPC::Core::CallOps
  extend ::Forwardable

  # Creates an ActiveCall.
  #
  # ActiveCall should only be created after a call is accepted.  That
  # means different things on a client and a server.  On the client, the
  # call is accepted after calling call.invoke.  On the server, this is
  # after call.accept.
  #
  # #initialize cannot determine if the call is accepted or not; so if a
  # call that's not accepted is used here, the error won't be visible until
  # the ActiveCall methods are called.
  #
  # deadline is the absolute deadline for the call.
  #
  # @param call [Call] the call used by the ActiveCall
  # @param marshal [Function] f(obj)->string that marshal requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param deadline [Fixnum] the deadline for the call to complete
  # @param started [true|false] indicates that metadata was sent
  # @param metadata_received [true|false] indicates if metadata has already
  #   been received. Should always be true for server calls
  # @return [ActiveCall] a new instance of ActiveCall
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#88
  def initialize(call, marshal, unmarshal, deadline, started: T.unsafe(nil), metadata_received: T.unsafe(nil), metadata_to_send: T.unsafe(nil)); end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#585
  def attach_peer_cert(peer_cert); end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#181
  def attach_status_results_and_complete_call(recv_status_batch_result); end

  # bidi_streamer sends a stream of requests to the GRPC server, and yields
  # a stream of responses.
  #
  # This method takes an Enumerable of requests, and returns and enumerable
  # of responses.
  #
  # == requests ==
  #
  # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
  # #each enumeration protocol. In the simplest case, requests will be an
  # array of marshallable objects; in typical case it will be an
  # Enumerable that allows dynamic construction of the marshallable
  # objects.
  #
  # == responses ==
  #
  # This is an enumerator of responses.  I.e, its #next method blocks
  # waiting for the next response.  Also, if at any point the block needs
  # to consume all the remaining responses, this can be done using #each or
  # #collect.  Calling #each or #collect should only be done if
  # the_call#writes_done has been called, otherwise the block will loop
  # forever.
  #
  # a list, multiple metadata for its key are sent
  #
  # @param requests [Object] an Enumerable of requests to send
  # @param metadata [Hash] metadata to be sent to the server. If a value is
  # @return [Enumerator, nil] a response Enumerator
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#500
  def bidi_streamer(requests, metadata: T.unsafe(nil), &blk); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancel(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancel_with_status(*args, **_arg1, &block); end

  # cancelled indicates if the call was cancelled
  #
  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#134
  def cancelled?; end

  # client_streamer sends a stream of requests to a GRPC server, and
  # returns a single response.
  #
  # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
  # #each enumeration protocol. In the simplest case, requests will be an
  # array of marshallable objects; in typical case it will be an Enumerable
  # that allows dynamic construction of the marshallable objects.
  #
  # a list, multiple metadata for its key are sent
  #
  # @param requests [Object] an Enumerable of requests to send
  # @param metadata [Hash] metadata to be sent to the server. If a value is
  # @return [Object] the response received from the server
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#399
  def client_streamer(requests, metadata: T.unsafe(nil)); end

  # Returns the value of attribute deadline.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#46
  def deadline; end

  # each_remote_read passes each response to the given block or returns an
  # enumerator the responses if no block is given.
  # Used to generate the request enumerable for
  # server-side client-streaming RPC's.
  #
  # == Enumerator ==
  #
  # * #next blocks until the remote endpoint sends a READ or FINISHED
  # * for each read, enumerator#next yields the response
  # * on status
  #    * if it's is OK, enumerator#next raises StopException
  #    * if is not OK, enumerator#next raises RuntimeException
  #
  # == Block ==
  #
  # * if provided it is executed for each response
  # * the call blocks until no more responses are provided
  #
  # @return [Enumerator] if no block was given
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#303
  def each_remote_read; end

  # each_remote_read_then_finish passes each response to the given block or
  # returns an enumerator of the responses if no block is given.
  #
  # It is like each_remote_read, but it blocks on finishing on detecting
  # the final message.
  #
  # == Enumerator ==
  #
  # * #next blocks until the remote endpoint sends a READ or FINISHED
  # * for each read, enumerator#next yields the response
  # * on status
  #    * if it's is OK, enumerator#next raises StopException
  #    * if is not OK, enumerator#next raises RuntimeException
  #
  # == Block ==
  #
  # * if provided it is executed for each response
  # * the call blocks until no more responses are provided
  #
  # @return [Enumerator] if no block was given
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#336
  def each_remote_read_then_finish; end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#275
  def get_message_from_batch_result(recv_message_batch_result); end

  # Returns a restricted view of this ActiveCall for use in interceptors
  #
  # @return [InterceptableView]
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#162
  def interceptable; end

  # Add to the metadata that will be sent from the server.
  # Fails if metadata has already been sent.
  # Unused by client calls.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#578
  def merge_metadata_to_send(new_metadata = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata(*args, **_arg1, &block); end

  # Returns the value of attribute metadata_sent.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#46
  def metadata_sent; end

  # Returns the value of attribute metadata_to_send.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#46
  def metadata_to_send; end

  # multi_req_view provides a restricted view of this ActiveCall for use
  # in a server client-streaming handler.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#140
  def multi_req_view; end

  # Signals that an operation is done.
  # Only relevant on the client-side (this is a no-op on the server-side)
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#570
  def op_is_done; end

  # operation provides a restricted view of this ActiveCall for use as
  # a Operation.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#152
  def operation; end

  # output_metadata are provides access to hash that can be used to
  # save metadata to be sent as trailer
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#129
  def output_metadata; end

  # Returns the value of attribute peer.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#46
  def peer; end

  # Returns the value of attribute peer_cert.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#46
  def peer_cert; end

  # Intended for use on server-side calls when a single request from
  # the client is expected (i.e., unary and server-streaming RPC types).
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#229
  def read_unary_request; end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#166
  def receive_and_check_status; end

  # remote_read reads a response from the remote endpoint.
  #
  # It blocks until the remote endpoint replies with a message or status.
  # On receiving a message, it returns the response after unmarshalling it.
  # On receiving a status, it returns nil if the status is OK, otherwise
  # raising BadStatus
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#258
  def remote_read; end

  # remote_send sends a request to the remote endpoint.
  #
  # It blocks until the remote endpoint accepts the message.
  #
  # marshalled.
  #
  # @param req [Object, String] the object to send or it's marshal form.
  # @param marshalled [false, true] indicates if the object is already
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#199
  def remote_send(req, marshalled = T.unsafe(nil)); end

  # request_response sends a request to a GRPC server, and returns the
  # response.
  #
  # a list, multiple metadata for its key are sent
  #
  # @param req [Object] the request sent to the server
  # @param metadata [Hash] metadata to be sent to the server. If a value is
  # @return [Object] the response received from the server
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#356
  def request_response(req, metadata: T.unsafe(nil)); end

  # run_server_bidi orchestrates a BiDi stream processing on a server.
  #
  # N.B. gen_each_reply is a func(Enumerable<Requests>)
  #
  # It takes an enumerable of requests as an arg, in case there is a
  # relationship between the stream of requests and the stream of replies.
  #
  # This does not mean that must necessarily be one.  E.g, the replies
  # produced by gen_each_reply could ignore the received_msgs
  #
  # @param mth [Proc] generates the BiDi stream replies
  # @param interception_ctx [InterceptionContext]
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#541
  def run_server_bidi(mth, interception_ctx); end

  # Sends the initial metadata that has yet to be sent.
  # Does nothing if metadata has already been sent for this call.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#118
  def send_initial_metadata(new_metadata = T.unsafe(nil)); end

  # send_status sends a status to the remote endpoint.
  #
  # FINISHED.
  # list, mulitple metadata for its key are sent
  #
  # @param code [int] the status code to send
  # @param details [String] details
  # @param assert_finished [true, false] when true(default), waits for
  # @param metadata [Hash] metadata to send to the server. If a value is a
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#214
  def send_status(code = T.unsafe(nil), details = T.unsafe(nil), assert_finished = T.unsafe(nil), metadata: T.unsafe(nil)); end

  # server_streamer sends one request to the GRPC server, which yields a
  # stream of responses.
  #
  # responses provides an enumerator over the streamed responses, i.e. it
  # follows Ruby's #each iteration protocol.  The enumerator blocks while
  # waiting for each response, stops when the server signals that no
  # further responses will be supplied.  If the implicit block is provided,
  # it is executed with each response as the argument and no result is
  # returned.
  #
  # a list, multiple metadata for its key are sent
  #
  # @param req [Object] the request sent to the server
  # @param metadata [Hash] metadata to be sent to the server. If a value is
  # @return [Enumerator|nil] a response Enumerator
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#442
  def server_streamer(req, metadata: T.unsafe(nil)); end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#235
  def server_unary_response(req, trailing_metadata: T.unsafe(nil), code: T.unsafe(nil), details: T.unsafe(nil)); end

  # single_req_view provides a restricted view of this ActiveCall for use in
  # a server request-response handler.
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#146
  def single_req_view; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def status(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def trailing_metadata(*args, **_arg1, &block); end

  # Waits till an operation completes
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#562
  def wait; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write_flag(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write_flag=(*args, **_arg1, &block); end

  private

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#611
  def maybe_finish_and_close_call_locked; end

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#628
  def raise_error_if_already_executed; end

  # To be called once the "input stream" has been completelly
  # read through (i.e, done reading from client or received status)
  # note this is idempotent
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#594
  def set_input_stream_done; end

  # To be called once the "output stream" has been completelly
  # sent through (i.e, done sending from client or sent status)
  # note this is idempotent
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#604
  def set_output_stream_done; end

  # Starts the call if not already started
  # a list, multiple metadata for its key are sent
  #
  # @param metadata [Hash] metadata to be sent to the server. If a value is
  #
  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#622
  def start_call(metadata = T.unsafe(nil)); end

  class << self
    # client_invoke begins a client invocation.
    #
    # Flow Control note: this blocks until flow control accepts that client
    # request can go ahead.
    #
    # deadline is the absolute deadline for the call.
    #
    # == Keyword Arguments ==
    # any keyword arguments are treated as metadata to be sent to the server
    # if a keyword value is a list, multiple metadata for it's key are sent
    #
    # @param call [Call] a call on which to start and invocation
    # @param metadata [Hash] the metadata
    #
    # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#63
    def client_invoke(call, metadata = T.unsafe(nil)); end

    # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#637
    def view_class(*visible_methods); end
  end
end

# InterceptableView further limits access to an ActiveCall's methods
# for use in interceptors on the client, exposing only the deadline
#
# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#638
class GRPC::ActiveCall::InterceptableView
  extend ::Forwardable

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#643
  def initialize(wrapped); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deadline(*args, **_arg1, &block); end
end

# MultiReqView limits access to an ActiveCall's methods for use in
# server client_streamer handlers.
#
# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#638
class GRPC::ActiveCall::MultiReqView
  extend ::Forwardable

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#643
  def initialize(wrapped); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancelled?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deadline(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_remote_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge_metadata_to_send(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata_sent(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata_to_send(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def output_metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_cert(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def send_initial_metadata(*args, **_arg1, &block); end
end

# Operation limits access to an ActiveCall's methods for use as
# a Operation on the client.
# TODO(apolcyn): expose peer getter
#
# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#638
class GRPC::ActiveCall::Operation
  extend ::Forwardable

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#643
  def initialize(wrapped); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancel(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancel_with_status(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancelled?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deadline(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def execute(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def start_call(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def status(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def trailing_metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def wait(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write_flag(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write_flag=(*args, **_arg1, &block); end
end

# SingleReqView limits access to an ActiveCall's methods for use in server
# handlers that receive just one request.
#
# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#638
class GRPC::ActiveCall::SingleReqView
  extend ::Forwardable

  # source://grpc//src/ruby/lib/grpc/generic/active_call.rb#643
  def initialize(wrapped); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cancelled?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deadline(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge_metadata_to_send(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata_sent(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def metadata_to_send(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def output_metadata(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_cert(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def send_initial_metadata(*args, **_arg1, &block); end
end

# GRPC status code corresponding to status ALREADY_EXISTS
#
# source://grpc//src/ruby/lib/grpc/errors.rb#169
class GRPC::AlreadyExists < ::GRPC::BadStatus
  # @return [AlreadyExists] a new instance of AlreadyExists
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#170
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# BadStatus is an exception class that indicates that an error occurred at
# either end of a GRPC connection.  When raised, it indicates that a status
# error should be returned to the other end of a GRPC connection; when
# caught it means that this end received a status error.
#
# There is also subclass of BadStatus in this module for each GRPC status.
# E.g., the GRPC::Cancelled class corresponds to status CANCELLED.
#
# See
# https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/status.h
# for detailed descriptions of each status code.
#
# source://grpc//src/ruby/lib/grpc/errors.rb#32
class GRPC::BadStatus < ::StandardError
  include ::GRPC::Core::StatusCodes

  # @param code [Numeric] the status code
  # @param details [String] the details of the exception
  # @param metadata [Hash] the error's metadata
  # @return [BadStatus] a new instance of BadStatus
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#40
  def initialize(code, details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#33
  def code; end

  # Returns the value of attribute debug_error_string.
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#33
  def debug_error_string; end

  # Returns the value of attribute details.
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#33
  def details; end

  # Returns the value of attribute metadata.
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#33
  def metadata; end

  # Converts the exception to a deserialized {Google::Rpc::Status} object.
  # Returns `nil` if the `grpc-status-details-bin` trailer could not be
  # converted to a {Google::Rpc::Status} due to the server not providing
  # the necessary trailers.
  #
  # @return [Google::Rpc::Status, nil]
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#69
  def to_rpc_status; end

  # Converts the exception to a {Struct::Status} for use in the networking
  # wrapper layer.
  #
  # @return [Struct::Status] with the same code and details
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#59
  def to_status; end

  class << self
    # source://grpc//src/ruby/lib/grpc/errors.rb#77
    def new_status_exception(code, details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
  end
end

# The BiDiCall class orchestrates execution of a BiDi stream on a client or
# server.
#
# source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#22
class GRPC::BidiCall
  include ::GRPC::Core::CallOps
  include ::GRPC::Core::StatusCodes
  include ::GRPC::Core::TimeConsts

  # Creates a BidiCall.
  #
  # BidiCall should only be created after a call is accepted.  That means
  # different things on a client and a server.  On the client, the call is
  # accepted after call.invoke. On the server, this is after call.accept.
  #
  # #initialize cannot determine if the call is accepted or not; so if a
  # call that's not accepted is used here, the error won't be visible until
  # the BidiCall#run is called.
  #
  # deadline is the absolute deadline for the call.
  #
  # @param call [Call] the call used by the ActiveCall
  # @param marshal [Function] f(obj)->string that marshal requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param metadata_received [true|false] indicates if metadata has already
  #   been received. Should always be true for server calls
  # @return [BidiCall] a new instance of BidiCall
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#44
  def initialize(call, marshal, unmarshal, metadata_received: T.unsafe(nil), req_view: T.unsafe(nil)); end

  # Read the next stream iteration
  #
  # @param finalize_stream [Proc] callback to call when the reads have been
  #   completely read through.
  # @param is_client [Boolean] If this is a client or server request
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#114
  def read_next_loop(finalize_stream, is_client = T.unsafe(nil)); end

  # Begins orchestration of the Bidi stream for a client sending requests.
  #
  # The method either returns an Enumerator of the responses, or accepts a
  # block that can be invoked with each response.
  #
  # @param requests the Enumerable of requests to send
  # @param set_input_stream_done [Proc] called back when we're done
  #   reading the input stream
  # @param set_output_stream_done [Proc] called back when we're done
  #   sending data on the output stream
  # @return an Enumerator of requests to yield
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#70
  def run_on_client(requests, set_input_stream_done, set_output_stream_done, &blk); end

  # Begins orchestration of the Bidi stream for a server generating replies.
  #
  # N.B. gen_each_reply is a func(Enumerable<Requests>)
  #
  # It takes an enumerable of requests as an arg, in case there is a
  # relationship between the stream of requests and the stream of replies.
  #
  # This does not mean that must necessarily be one.  E.g, the replies
  # produced by gen_each_reply could ignore the received_msgs
  #
  # @param gen_each_reply [Proc] generates the BiDi stream replies.
  # @param requests [Enumerable] The enumerable of requests to run
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#92
  def run_on_server(gen_each_reply, requests); end

  private

  # Provides an enumerator that yields results of remote reads
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#191
  def read_loop(set_input_stream_done, is_client: T.unsafe(nil)); end

  # performs a read using @call.run_batch, ensures metadata is set up
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#124
  def read_using_run_batch; end

  # set_output_stream_done is relevant on client-side
  #
  # source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#143
  def write_loop(requests, is_client: T.unsafe(nil), set_output_stream_done: T.unsafe(nil)); end
end

# source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#120
GRPC::BidiCall::END_OF_READS = T.let(T.unsafe(nil), Symbol)

# source://grpc//src/ruby/lib/grpc/generic/bidi_call.rb#121
GRPC::BidiCall::END_OF_WRITES = T.let(T.unsafe(nil), Symbol)

# GRPC status code corresponding to status CANCELLED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#119
class GRPC::Cancelled < ::GRPC::BadStatus
  # @return [Cancelled] a new instance of Cancelled
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#120
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# ClientInterceptor allows for wrapping outbound gRPC client stub requests.
# This is an EXPERIMENTAL API.
#
# source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#35
class GRPC::ClientInterceptor < ::GRPC::Interceptor
  # Intercept a BiDi streaming call
  #
  # @param requests [Enumerable]
  # @param call [GRPC::ActiveCall]
  # @param method [String]
  # @param metadata [Hash]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#86
  def bidi_streamer(requests: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Intercept a client streaming call
  #
  # @param requests [Enumerable]
  # @param call [GRPC::ActiveCall]
  # @param method [String]
  # @param metadata [Hash]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#58
  def client_streamer(requests: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Intercept a unary request response call
  #
  # @param request [Object]
  # @param call [GRPC::ActiveCall]
  # @param method [String]
  # @param metadata [Hash]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#44
  def request_response(request: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Intercept a server streaming call
  #
  # @param request [Object]
  # @param call [GRPC::ActiveCall]
  # @param method [String]
  # @param metadata [Hash]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#72
  def server_streamer(request: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil), metadata: T.unsafe(nil)); end
end

# ClientStub represents a client connection to a gRPC server, and can be used
# to send requests.
#
# source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#24
class GRPC::ClientStub
  include ::GRPC::Core::StatusCodes
  include ::GRPC::Core::TimeConsts

  # Creates a new ClientStub.
  #
  # Minimally, a stub is created with the just the host of the gRPC service
  # it wishes to access, e.g.,
  #
  #   my_stub = ClientStub.new(example.host.com:50505,
  #                            :this_channel_is_insecure)
  #
  # If a channel_override argument is passed, it will be used as the
  # underlying channel. Otherwise, the channel_args argument will be used
  # to construct a new underlying channel.
  #
  # There are some specific keyword args that are not used to configure the
  # channel:
  #
  # - :channel_override
  # when present, this must be a pre-created GRPC::Core::Channel.  If it's
  # present the host and arbitrary keyword arg areignored, and the RPC
  # connection uses this channel.
  #
  # - :timeout
  # when present, this is the default timeout used for calls
  #
  # @param host [String] the host the stub connects to
  # @param creds [Core::ChannelCredentials|Symbol] the channel credentials, or
  #   :this_channel_is_insecure, which explicitly indicates that the client
  #   should be created with an insecure connection. Note: this argument is
  #   ignored if the channel_override argument is provided.
  # @param channel_override [Core::Channel] a pre-created channel
  # @param timeout [Number] the default timeout to use in requests
  # @param propagate_mask [Number] A bitwise combination of flags in
  #   GRPC::Core::PropagateMasks. Indicates how data should be propagated
  #   from parent server calls to child client calls if this client is being
  #   used within a gRPC server.
  # @param channel_args [Hash] the channel arguments. Note: this argument is
  #   ignored if the channel_override argument is provided.
  # @param interceptors [Array<GRPC::ClientInterceptor>] An array of
  #   GRPC::ClientInterceptor objects that will be used for
  #   intercepting calls before they are executed
  #   Interceptors are an EXPERIMENTAL API.
  # @return [ClientStub] a new instance of ClientStub
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#98
  def initialize(host, creds, channel_override: T.unsafe(nil), timeout: T.unsafe(nil), propagate_mask: T.unsafe(nil), channel_args: T.unsafe(nil), interceptors: T.unsafe(nil)); end

  # bidi_streamer sends a stream of requests to the GRPC server, and yields
  # a stream of responses.
  #
  # This method takes an Enumerable of requests, and returns and enumerable
  # of responses.
  #
  # == requests ==
  #
  # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
  # #each enumeration protocol. In the simplest case, requests will be an
  # array of marshallable objects; in typical case it will be an
  # Enumerable that allows dynamic construction of the marshallable
  # objects.
  #
  # == responses ==
  #
  # This is an enumerator of responses.  I.e, its #next method blocks
  # waiting for the next response.  Also, if at any point the block needs
  # to consume all the remaining responses, this can be done using #each or
  # #collect.  Calling #each or #collect should only be done if
  # the_call#writes_done has been called, otherwise the block will loop
  # forever.
  #
  # == Flow Control ==
  # This is a blocking call.
  #
  # * the call completes when the next call to provided block returns
  #   false
  #
  # * the execution block parameters are two objects for sending and
  #   receiving responses, each of which blocks waiting for flow control.
  #   E.g, calles to bidi_call#remote_send will wait until flow control
  #   allows another write before returning; and obviously calls to
  #   responses#next block until the next response is available.
  #
  # == Termination ==
  #
  # As well as sending and receiving messages, the block passed to the
  # function is also responsible for:
  #
  # * calling bidi_call#writes_done to indicate no further reqs will be
  #   sent.
  #
  # * returning false if once the bidi stream is functionally completed.
  #
  # Note that response#next will indicate that there are no further
  # responses by throwing StopIteration, but can only happen either
  # if bidi_call#writes_done is called.
  #
  # To properly terminate the RPC, the responses should be completely iterated
  # through; one way to do this is to loop on responses#next until no further
  # responses are available.
  #
  # == Errors ==
  # An RuntimeError is raised if
  #
  # * the server responds with a non-OK status when any response is
  # * retrieved
  #
  # * the deadline is exceeded
  #
  #
  # == Return Value ==
  #
  # if the return_op is false, the return value is an Enumerator of the
  # results, unless a block is provided, in which case the block is
  # executed with each response.
  #
  # if return_op is true, the function returns an Operation whose #execute
  # method runs the Bidi call. Again, Operation#execute either calls a
  # given block with each response or returns an Enumerator of the
  # responses.
  #
  # @param method [String] the RPC method to call on the GRPC server
  # @param requests [Object] an Enumerable of requests to send
  # @param marshal [Function] f(obj)->string that marshals requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param deadline [Time] (optional) the time the request should complete
  # @param return_op [true|false] return an Operation if true
  # @param parent [Core::Call] a prior call whose reserved metadata
  #   will be propagated by this one.
  # @param credentials [Core::CallCredentials] credentials to use when making
  #   the call
  # @param metadata [Hash] metadata to be sent to the server
  # @param blk [Block] when provided, is executed for each response
  # @return [Enumerator|nil|Operation] as discussed above
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#440
  def bidi_streamer(method, requests, marshal, unmarshal, deadline: T.unsafe(nil), return_op: T.unsafe(nil), parent: T.unsafe(nil), credentials: T.unsafe(nil), metadata: T.unsafe(nil), &blk); end

  # client_streamer sends a stream of requests to a GRPC server, and
  # returns a single response.
  #
  # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
  # #each enumeration protocol. In the simplest case, requests will be an
  # array of marshallable objects; in typical case it will be an Enumerable
  # that allows dynamic construction of the marshallable objects.
  #
  # == Flow Control ==
  # This is a blocking call.
  #
  # * it does not return until a response is received.
  #
  # * each requests is sent only when GRPC core's flow control allows it to
  #   be sent.
  #
  # == Errors ==
  # An RuntimeError is raised if
  #
  # * the server responds with a non-OK status
  #
  # * the deadline is exceeded
  #
  # == Return Value ==
  #
  # If return_op is false, the call consumes the requests and returns
  # the response.
  #
  # If return_op is true, the call returns the response.
  #
  # @param method [String] the RPC method to call on the GRPC server
  # @param requests [Object] an Enumerable of requests to send
  # @param marshal [Function] f(obj)->string that marshals requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param deadline [Time] (optional) the time the request should complete
  # @param return_op [true|false] return an Operation if true
  # @param parent [Core::Call] a prior call whose reserved metadata
  #   will be propagated by this one.
  # @param credentials [Core::CallCredentials] credentials to use when making
  #   the call
  # @param metadata [Hash] metadata to be sent to the server
  # @return [Object|Operation] the response received from the server
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#227
  def client_streamer(method, requests, marshal, unmarshal, deadline: T.unsafe(nil), return_op: T.unsafe(nil), parent: T.unsafe(nil), credentials: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Allows users of the stub to modify the propagate mask.
  #
  # This is an advanced feature for use when making calls to another gRPC
  # server whilst running in the handler of an existing one.
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#56
  def propagate_mask=(_arg0); end

  # request_response sends a request to a GRPC server, and returns the
  # response.
  #
  # == Flow Control ==
  # This is a blocking call.
  #
  # * it does not return until a response is received.
  #
  # * the requests is sent only when GRPC core's flow control allows it to
  #   be sent.
  #
  # == Errors ==
  # An RuntimeError is raised if
  #
  # * the server responds with a non-OK status
  #
  # * the deadline is exceeded
  #
  # == Return Value ==
  #
  # If return_op is false, the call returns the response
  #
  # If return_op is true, the call returns an Operation, calling execute
  # on the Operation returns the response.
  #
  # @param method [String] the RPC method to call on the GRPC server
  # @param req [Object] the request sent to the server
  # @param marshal [Function] f(obj)->string that marshals requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param deadline [Time] (optional) the time the request should complete
  # @param return_op [true|false] return an Operation if true
  # @param parent [Core::Call] a prior call whose reserved metadata
  #   will be propagated by this one.
  # @param credentials [Core::CallCredentials] credentials to use when making
  #   the call
  # @param metadata [Hash] metadata to be sent to the server
  # @return [Object] the response received from the server
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#150
  def request_response(method, req, marshal, unmarshal, deadline: T.unsafe(nil), return_op: T.unsafe(nil), parent: T.unsafe(nil), credentials: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # server_streamer sends one request to the GRPC server, which yields a
  # stream of responses.
  #
  # responses provides an enumerator over the streamed responses, i.e. it
  # follows Ruby's #each iteration protocol.  The enumerator blocks while
  # waiting for each response, stops when the server signals that no
  # further responses will be supplied.  If the implicit block is provided,
  # it is executed with each response as the argument and no result is
  # returned.
  #
  # == Flow Control ==
  # This is a blocking call.
  #
  # * the request is sent only when GRPC core's flow control allows it to
  #   be sent.
  #
  # * the request will not complete until the server sends the final
  #   response followed by a status message.
  #
  # == Errors ==
  # An RuntimeError is raised if
  #
  # * the server responds with a non-OK status when any response is
  # * retrieved
  #
  # * the deadline is exceeded
  #
  # == Return Value ==
  #
  # if the return_op is false, the return value is an Enumerator of the
  # results, unless a block is provided, in which case the block is
  # executed with each response.
  #
  # if return_op is true, the function returns an Operation whose #execute
  # method runs server streamer call. Again, Operation#execute either
  # calls the given block with each response or returns an Enumerator of the
  # responses.
  #
  # == Keyword Args ==
  #
  # Unspecified keyword arguments are treated as metadata to be sent to the
  # server.
  #
  # @param method [String] the RPC method to call on the GRPC server
  # @param req [Object] the request sent to the server
  # @param marshal [Function] f(obj)->string that marshals requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param deadline [Time] (optional) the time the request should complete
  # @param return_op [true|false] return an Operation if true
  # @param parent [Core::Call] a prior call whose reserved metadata
  #   will be propagated by this one.
  # @param credentials [Core::CallCredentials] credentials to use when making
  #   the call
  # @param metadata [Hash] metadata to be sent to the server
  # @param blk [Block] when provided, is executed for each response
  # @return [Enumerator|Operation|nil] as discussed above
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#318
  def server_streamer(method, req, marshal, unmarshal, deadline: T.unsafe(nil), return_op: T.unsafe(nil), parent: T.unsafe(nil), credentials: T.unsafe(nil), metadata: T.unsafe(nil), &blk); end

  private

  # Creates a new active stub
  #
  # @param method [string] the method being called.
  # @param marshal [Function] f(obj)->string that marshals requests
  # @param unmarshal [Function] f(string)->obj that unmarshals responses
  # @param parent [Grpc::Call] a parent call, available when calls are
  #   made from server
  # @param credentials [Core::CallCredentials] credentials to use when making
  #   the call
  #
  # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#487
  def new_active_call(method, marshal, unmarshal, deadline: T.unsafe(nil), parent: T.unsafe(nil), credentials: T.unsafe(nil)); end

  class << self
    # setup_channel is used by #initialize to constuct a channel from its
    # arguments.
    #
    # source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#33
    def setup_channel(alt_chan, host, creds, channel_args = T.unsafe(nil)); end
  end
end

# Default timeout is infinity.
#
# source://grpc//src/ruby/lib/grpc/generic/client_stub.rb#29
GRPC::ClientStub::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), GRPC::Core::TimeSpec)

# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#17
module GRPC::Core
  private

  def fork_unsafe_begin; end
  def fork_unsafe_end; end

  class << self
    def fork_unsafe_begin; end
    def fork_unsafe_end; end
  end
end

class GRPC::Core::Call
  def initialize; end

  def cancel; end
  def cancel_with_status(_arg0, _arg1); end
  def close; end
  def metadata; end
  def metadata=(_arg0); end
  def peer; end
  def peer_cert; end
  def run_batch(_arg0); end
  def set_credentials!(_arg0); end
  def status; end
  def status=(_arg0); end
  def trailing_metadata; end
  def trailing_metadata=(_arg0); end
  def write_flag; end
  def write_flag=(_arg0); end

  private

  def initialize_copy(_arg0); end
end

class GRPC::Core::CallCredentials
  def initialize(_arg0); end

  def compose(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class GRPC::Core::CallError < ::Exception; end
module GRPC::Core::CallOps; end
GRPC::Core::CallOps::RECV_CLOSE_ON_SERVER = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::RECV_INITIAL_METADATA = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::RECV_MESSAGE = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::RECV_STATUS_ON_CLIENT = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::SEND_CLOSE_FROM_CLIENT = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::SEND_INITIAL_METADATA = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::SEND_MESSAGE = T.let(T.unsafe(nil), Integer)
GRPC::Core::CallOps::SEND_STATUS_FROM_SERVER = T.let(T.unsafe(nil), Integer)

class GRPC::Core::Channel
  def initialize(*_arg0); end

  def close; end
  def connectivity_state(*_arg0); end
  def create_call(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def destroy; end
  def target; end
  def watch_connectivity_state(_arg0, _arg1); end

  private

  def initialize_copy(_arg0); end
end

GRPC::Core::Channel::ENABLE_CENSUS = T.let(T.unsafe(nil), Symbol)
GRPC::Core::Channel::MAX_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Symbol)
GRPC::Core::Channel::MAX_MESSAGE_LENGTH = T.let(T.unsafe(nil), Symbol)
GRPC::Core::Channel::SSL_TARGET = T.let(T.unsafe(nil), Symbol)

class GRPC::Core::ChannelCredentials
  def initialize(*_arg0); end

  def compose(*_arg0); end

  private

  def initialize_copy(_arg0); end
  def set_default_roots_pem(_arg0); end

  class << self
    def set_default_roots_pem(_arg0); end
  end
end

class GRPC::Core::CompressionOptions
  def initialize(*_arg0); end

  def algorithm_enabled?(_arg0); end
  def default_algorithm; end
  def default_level; end
  def disabled_algorithms; end
  def to_channel_arg_hash; end
  def to_hash; end
end

module GRPC::Core::ConnectivityStates; end
GRPC::Core::ConnectivityStates::CONNECTING = T.let(T.unsafe(nil), Integer)
GRPC::Core::ConnectivityStates::FATAL_FAILURE = T.let(T.unsafe(nil), Integer)
GRPC::Core::ConnectivityStates::IDLE = T.let(T.unsafe(nil), Integer)
GRPC::Core::ConnectivityStates::READY = T.let(T.unsafe(nil), Integer)
GRPC::Core::ConnectivityStates::TRANSIENT_FAILURE = T.let(T.unsafe(nil), Integer)
class GRPC::Core::MetadataArray; end
module GRPC::Core::MetadataKeys; end
GRPC::Core::MetadataKeys::COMPRESSION_REQUEST_ALGORITHM = T.let(T.unsafe(nil), String)
class GRPC::Core::OutOfTime < ::Exception; end
module GRPC::Core::PropagateMasks; end
GRPC::Core::PropagateMasks::CANCELLATION = T.let(T.unsafe(nil), Integer)
GRPC::Core::PropagateMasks::CENSUS_STATS_CONTEXT = T.let(T.unsafe(nil), Integer)
GRPC::Core::PropagateMasks::CENSUS_TRACING_CONTEXT = T.let(T.unsafe(nil), Integer)
GRPC::Core::PropagateMasks::DEADLINE = T.let(T.unsafe(nil), Integer)
GRPC::Core::PropagateMasks::DEFAULTS = T.let(T.unsafe(nil), Integer)
module GRPC::Core::RpcErrors; end
GRPC::Core::RpcErrors::ALREADY_ACCEPTED = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::ALREADY_FINISHED = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::ALREADY_INVOKED = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::ERROR = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::ErrorMessages = T.let(T.unsafe(nil), Hash)
GRPC::Core::RpcErrors::INVALID_FLAGS = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::NOT_INVOKED = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::NOT_ON_CLIENT = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::NOT_ON_SERVER = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::OK = T.let(T.unsafe(nil), Integer)
GRPC::Core::RpcErrors::TOO_MANY_OPERATIONS = T.let(T.unsafe(nil), Integer)

class GRPC::Core::Server
  def initialize(_arg0); end

  def add_http2_port(_arg0, _arg1); end
  def close; end
  def destroy; end
  def request_call; end
  def shutdown_and_notify(_arg0); end
  def start; end

  private

  def initialize_copy(_arg0); end
end

class GRPC::Core::ServerCredentials
  def initialize(_arg0, _arg1, _arg2); end

  private

  def initialize_copy(_arg0); end
end

# StatusCodes defines the canonical error codes used by gRPC for the RPC
# API.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#20
module GRPC::Core::StatusCodes; end

# Aborted indicates the operation was aborted, typically due to a
# concurrency issue like sequencer check failures, transaction aborts,
# etc.
#
# See litmus test above for deciding between FailedPrecondition, Aborted,
# and Unavailable.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#93
GRPC::Core::StatusCodes::ABORTED = T.let(T.unsafe(nil), Integer)

# AlreadyExists means an attempt to create an entity failed because one
# already exists.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#53
GRPC::Core::StatusCodes::ALREADY_EXISTS = T.let(T.unsafe(nil), Integer)

# Canceled indicates the operation was canceled (typically by the caller).
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#25
GRPC::Core::StatusCodes::CANCELLED = T.let(T.unsafe(nil), Integer)

# DataLoss indicates unrecoverable data loss or corruption.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#128
GRPC::Core::StatusCodes::DATA_LOSS = T.let(T.unsafe(nil), Integer)

# DeadlineExceeded means operation expired before completion. For
# operations that change the state of the system, this error may be
# returned even if the operation has completed successfully. For example,
# a successful response from a server could have been delayed long enough
# for the deadline to expire.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#45
GRPC::Core::StatusCodes::DEADLINE_EXCEEDED = T.let(T.unsafe(nil), Integer)

# FailedPrecondition indicates operation was rejected because the system
# is not in a state required for the operation's execution. For example,
# directory to be deleted may be non-empty, an rmdir operation is applied
# to a non-directory, etc.
#
# A litmus test that may help a service implementor in deciding between
# FailedPrecondition, Aborted, and Unavailable:
#  (a) Use Unavailable if the client can retry just the failing call.
#  (b) Use Aborted if the client should retry at a higher-level (e.g.,
#      restarting a read-modify-write sequence).
#  (c) Use FailedPrecondition if the client should not retry until the
#      system state has been explicitly fixed. E.g., if an "rmdir" fails
#      because the directory is non-empty, FailedPrecondition should be
#      returned since the client should not retry unless they have first
#      fixed up the directory by deleting files from it.
#  (d) Use FailedPrecondition if the client performs conditional REST
#      Get/Update/Delete on a resource and the resource on the server does
#      not match the condition. E.g., conflicting read-modify-write on the
#      same resource.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#85
GRPC::Core::StatusCodes::FAILED_PRECONDITION = T.let(T.unsafe(nil), Integer)

# Internal errors. Means some invariants expected by underlying system has
# been broken. If you see one of these errors, something is very broken.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#116
GRPC::Core::StatusCodes::INTERNAL = T.let(T.unsafe(nil), Integer)

# InvalidArgument indicates client specified an invalid argument. Note
# that this differs from FailedPrecondition. It indicates arguments that
# are problematic regardless of the state of the system (e.g., a malformed
# file name).
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#38
GRPC::Core::StatusCodes::INVALID_ARGUMENT = T.let(T.unsafe(nil), Integer)

# NotFound means some requested entity (e.g., file or directory) was not
# found.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#49
GRPC::Core::StatusCodes::NOT_FOUND = T.let(T.unsafe(nil), Integer)

# OK is returned on success.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#22
GRPC::Core::StatusCodes::OK = T.let(T.unsafe(nil), Integer)

# OutOfRange means operation was attempted past the valid range. E.g.,
# seeking or reading past end of file.
#
# Unlike InvalidArgument, this error indicates a problem that may be fixed
# if the system state changes. For example, a 32-bit file system will
# generate InvalidArgument if asked to read at an offset that is not in
# the range [0,2^32-1], but it will generate OutOfRange if asked to read
# from an offset past the current file size.
#
# There is a fair bit of overlap between FailedPrecondition and
# OutOfRange. We recommend using OutOfRange (the more specific error) when
# it applies so that callers who are iterating through a space can easily
# look for an OutOfRange error to detect when they are done.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#108
GRPC::Core::StatusCodes::OUT_OF_RANGE = T.let(T.unsafe(nil), Integer)

# PermissionDenied indicates the caller does not have permission to
# execute the specified operation. It must not be used for rejections
# caused by exhausting some resource (use ResourceExhausted instead for
# those errors). It must not be used if the caller cannot be identified
# (use Unauthenticated instead for those errors).
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#60
GRPC::Core::StatusCodes::PERMISSION_DENIED = T.let(T.unsafe(nil), Integer)

# ResourceExhausted indicates some resource has been exhausted, perhaps a
# per-user quota, or perhaps the entire file system is out of space.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#64
GRPC::Core::StatusCodes::RESOURCE_EXHAUSTED = T.let(T.unsafe(nil), Integer)

# Unauthenticated indicates the request does not have valid authentication
# credentials for the operation.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#132
GRPC::Core::StatusCodes::UNAUTHENTICATED = T.let(T.unsafe(nil), Integer)

# Unavailable indicates the service is currently unavailable. This is a
# most likely a transient condition and may be corrected by retrying with
# a backoff. Note that it is not always safe to retry non-idempotent
# operations.
#
# See litmus test above for deciding between FailedPrecondition, Aborted,
# and Unavailable.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#125
GRPC::Core::StatusCodes::UNAVAILABLE = T.let(T.unsafe(nil), Integer)

# Unimplemented indicates operation is not implemented or not
# supported/enabled in this service.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#112
GRPC::Core::StatusCodes::UNIMPLEMENTED = T.let(T.unsafe(nil), Integer)

# Unknown error. An example of where this error may be returned is if a
# Status value received from another address space belongs to an
# error-space that is not known in this address space. Also errors raised
# by APIs that do not return enough error information may be converted to
# this error.
#
# source://grpc//src/ruby/lib/grpc/core/status_codes.rb#32
GRPC::Core::StatusCodes::UNKNOWN = T.let(T.unsafe(nil), Integer)

# TimeConsts is a module from the C extension.
#
# Here it's re-opened to add a utility func.
#
# source://grpc//src/ruby/lib/grpc/core/time_consts.rb#23
module GRPC::Core::TimeConsts
  private

  # Converts a time delta to an absolute deadline.
  #
  # Assumes timeish is a relative time, and converts its to an absolute,
  # with following exceptions:
  #
  # * if timish is one of the TimeConsts.TimeSpec constants the value is
  # preserved.
  # * timish < 0 => TimeConsts.INFINITE_FUTURE
  # * timish == 0 => TimeConsts.ZERO
  #
  # @param timeish [Number|TimeSpec]
  # @return [Number|TimeSpec]
  #
  # source://grpc//src/ruby/lib/grpc/core/time_consts.rb#36
  def from_relative_time(timeish); end

  class << self
    # Converts a time delta to an absolute deadline.
    #
    # Assumes timeish is a relative time, and converts its to an absolute,
    # with following exceptions:
    #
    # * if timish is one of the TimeConsts.TimeSpec constants the value is
    # preserved.
    # * timish < 0 => TimeConsts.INFINITE_FUTURE
    # * timish == 0 => TimeConsts.ZERO
    #
    # @param timeish [Number|TimeSpec]
    # @return [Number|TimeSpec]
    #
    # source://grpc//src/ruby/lib/grpc/core/time_consts.rb#36
    def from_relative_time(timeish); end
  end
end

GRPC::Core::TimeConsts::INFINITE_FUTURE = T.let(T.unsafe(nil), GRPC::Core::TimeSpec)
GRPC::Core::TimeConsts::INFINITE_PAST = T.let(T.unsafe(nil), GRPC::Core::TimeSpec)
GRPC::Core::TimeConsts::ZERO = T.let(T.unsafe(nil), GRPC::Core::TimeSpec)

class GRPC::Core::TimeSpec
  def inspect; end
  def to_s; end
  def to_time; end
end

module GRPC::Core::WriteFlags; end
GRPC::Core::WriteFlags::BUFFER_HINT = T.let(T.unsafe(nil), Integer)
GRPC::Core::WriteFlags::NO_COMPRESS = T.let(T.unsafe(nil), Integer)

class GRPC::Core::XdsChannelCredentials
  def initialize(_arg0); end

  def compose(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class GRPC::Core::XdsServerCredentials
  def initialize(_arg0); end

  private

  def initialize_copy(_arg0); end
end

# GRPC status code corresponding to status DATA_LOSS
#
# source://grpc//src/ruby/lib/grpc/errors.rb#269
class GRPC::DataLoss < ::GRPC::BadStatus
  # @return [DataLoss] a new instance of DataLoss
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#270
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status DEADLINE_EXCEEDED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#149
class GRPC::DeadlineExceeded < ::GRPC::BadStatus
  # @return [DeadlineExceeded] a new instance of DeadlineExceeded
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#150
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# DefaultLogger is a module included in GRPC if no other logging is set up for
# it.  See ../spec/spec_helpers an example of where other logging is added.
#
# source://grpc//src/ruby/lib/grpc/logconfig.rb#32
module GRPC::DefaultLogger
  # source://grpc//src/ruby/lib/grpc/logconfig.rb#33
  def logger; end
end

# source://grpc//src/ruby/lib/grpc/logconfig.rb#52
GRPC::DefaultLogger::LOGGER = T.let(T.unsafe(nil), GRPC::DefaultLogger::NoopLogger)

# NoopLogger implements the methods of Ruby's conventional logging interface
# that are actually used internally within gRPC with a noop implementation.
#
# source://grpc//src/ruby/lib/grpc/logconfig.rb#41
class GRPC::DefaultLogger::NoopLogger
  # source://grpc//src/ruby/lib/grpc/logconfig.rb#45
  def debug(_ignored); end

  # source://grpc//src/ruby/lib/grpc/logconfig.rb#42
  def info(_ignored); end

  # source://grpc//src/ruby/lib/grpc/logconfig.rb#48
  def warn(_ignored); end
end

# GRPC status code corresponding to status FAILED_PRECONDITION
#
# source://grpc//src/ruby/lib/grpc/errors.rb#209
class GRPC::FailedPrecondition < ::GRPC::BadStatus
  # @return [FailedPrecondition] a new instance of FailedPrecondition
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#210
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# Provides behaviour used to implement schema-derived service classes.
#
# Is intended to be used to support both client and server
# IDL-schema-derived servers.
#
# source://grpc//src/ruby/lib/grpc/generic/service.rb#24
module GRPC::GenericService
  mixes_in_class_methods ::GRPC::GenericService::Dsl

  class << self
    # @private
    #
    # source://grpc//src/ruby/lib/grpc/generic/service.rb#194
    def included(o); end

    # creates a new string that is the underscore separate version of s.
    #
    # E.g,
    # PrintHTML -> print_html
    # AMethod -> a_method
    # AnRpc -> an_rpc
    #
    # @param s [String] the string to be converted.
    #
    # source://grpc//src/ruby/lib/grpc/generic/service.rb#33
    def underscore(s); end
  end
end

# Provides a simple DSL to describe RPC services.
#
# E.g, a Maths service that uses the serializable messages DivArgs,
# DivReply and Num might define its endpoint uses the following way:
#
# rpc :div DivArgs, DivReply    # single request, single response
# rpc :sum stream(Num), Num     # streamed input, single response
# rpc :fib FibArgs, stream(Num) # single request, streamed response
# rpc :div_many stream(DivArgs), stream(DivReply)
#                               # streamed req and resp
#
# Each 'rpc' adds an RpcDesc to classes including this module, and
# #assert_rpc_descs_have_methods is used to ensure the including class
# provides methods with signatures that support all the descriptors.
#
# source://grpc//src/ruby/lib/grpc/generic/service.rb#63
module GRPC::GenericService::Dsl
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#123
  def assert_can_marshal(cls); end

  # source://grpc//src/ruby/lib/grpc/generic/service.rb#105
  def inherited(subclass); end

  # the name of the instance method used to marshal events to a byte
  # stream.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#114
  def marshal_class_method; end

  # This configures the method names that the serializable message
  # implementation uses to marshal and unmarshal messages.
  #
  # - unmarshal_class method must be a class method on the serializable
  # message type that takes a string (byte stream) and produces and object
  #
  # - marshal_class_method is called on a serializable message instance
  # and produces a serialized string.
  #
  # The Dsl verifies that the types in the descriptor have both the
  # unmarshal and marshal methods.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#75
  def marshal_class_method=(_arg0); end

  # Adds an RPC spec.
  #
  # Takes the RPC name and the classes representing the types to be
  # serialized, and adds them to the including classes rpc_desc hash.
  #
  # input and output should both have the methods #marshal and #unmarshal
  # that are responsible for writing and reading an object instance from a
  # byte buffer respectively.
  #
  # @param name [String] the name of the rpc
  # @param input [Object] the input parameter's class
  # @param output [Object] the output parameter's class
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#92
  def rpc(name, input, output); end

  # the RpcDescs defined for this GenericService, keyed by name.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#142
  def rpc_descs; end

  # Creates a rpc client class with methods for accessing the methods
  # currently in rpc_descs.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#148
  def rpc_stub_class; end

  # This allows configuration of the service name.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#78
  def service_name; end

  # This allows configuration of the service name.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#78
  def service_name=(_arg0); end

  # @param cls [Class] the class of a serializable type
  # @return cls wrapped in a RpcDesc::Stream
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#136
  def stream(cls); end

  # the name of the class method used to unmarshal from a byte stream.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#119
  def unmarshal_class_method; end

  # This configures the method names that the serializable message
  # implementation uses to marshal and unmarshal messages.
  #
  # - unmarshal_class method must be a class method on the serializable
  # message type that takes a string (byte stream) and produces and object
  #
  # - marshal_class_method is called on a serializable message instance
  # and produces a serialized string.
  #
  # The Dsl verifies that the types in the descriptor have both the
  # unmarshal and marshal methods.
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#75
  def unmarshal_class_method=(_arg0); end
end

# Used to indicate that a name has already been specified
#
# source://grpc//src/ruby/lib/grpc/generic/service.rb#43
class GRPC::GenericService::DuplicateRpcName < ::StandardError
  # @return [DuplicateRpcName] a new instance of DuplicateRpcName
  #
  # source://grpc//src/ruby/lib/grpc/generic/service.rb#44
  def initialize(name); end
end

# GoogleRpcStatusUtils provides utilities to convert between a
# GRPC::Core::Status and a deserialized Google::Rpc::Status proto
# Returns nil if the grpc-status-details-bin trailer could not be
# converted to a GoogleRpcStatus due to the server not providing
# the necessary trailers.
# Raises an error if the server did provide the necessary trailers
# but they fail to deseriliaze into a GoogleRpcStatus protobuf.
#
# source://grpc//src/ruby/lib/grpc/google_rpc_status_utils.rb#26
class GRPC::GoogleRpcStatusUtils
  class << self
    # source://grpc//src/ruby/lib/grpc/google_rpc_status_utils.rb#27
    def extract_google_rpc_status(status); end
  end
end

# Represents the context in which an interceptor runs. Used to provide an
# injectable mechanism for handling interception. This is an EXPERIMENTAL API.
#
# source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#154
class GRPC::InterceptionContext
  # @param interceptors [Array<GRPC::Interceptor>]
  # @return [InterceptionContext] a new instance of InterceptionContext
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#158
  def initialize(interceptors = T.unsafe(nil)); end

  # Intercept the call and fire out to interceptors in a FIFO execution.
  # This is an EXPERIMENTAL API.
  #
  # @param type [Symbol] The request type
  # @param args [Hash] The arguments for the call
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#169
  def intercept!(type, args = T.unsafe(nil)); end
end

# Base class for interception in GRPC
#
# source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#21
class GRPC::Interceptor
  # @param options [Hash] A hash of options that will be used
  #   by the interceptor. This is an EXPERIMENTAL API.
  # @return [Interceptor] a new instance of Interceptor
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#26
  def initialize(options = T.unsafe(nil)); end
end

# Represents a registry of added interceptors available for enumeration.
# The registry can be used for both server and client interceptors.
# This class is internal to gRPC and not meant for public usage.
#
# source://grpc//src/ruby/lib/grpc/generic/interceptor_registry.rb#22
class GRPC::InterceptorRegistry
  # Initialize the registry with an empty interceptor list
  # This is an EXPERIMENTAL API.
  #
  # @return [InterceptorRegistry] a new instance of InterceptorRegistry
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptor_registry.rb#33
  def initialize(interceptors = T.unsafe(nil)); end

  # Builds an interception context from this registry
  #
  # @return [InterceptionContext]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptor_registry.rb#49
  def build_context; end
end

# An error raised when an interceptor is attempted to be added
# that does not extend GRPC::Interceptor
#
# source://grpc//src/ruby/lib/grpc/generic/interceptor_registry.rb#27
class GRPC::InterceptorRegistry::DescendantError < ::StandardError; end

# GRPC status code corresponding to status INTERNAL
#
# source://grpc//src/ruby/lib/grpc/errors.rb#249
class GRPC::Internal < ::GRPC::BadStatus
  # @return [Internal] a new instance of Internal
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#250
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status INVALID_ARGUMENT
#
# source://grpc//src/ruby/lib/grpc/errors.rb#139
class GRPC::InvalidArgument < ::GRPC::BadStatus
  # @return [InvalidArgument] a new instance of InvalidArgument
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#140
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status NOT_FOUND
#
# source://grpc//src/ruby/lib/grpc/errors.rb#159
class GRPC::NotFound < ::GRPC::BadStatus
  # @return [NotFound] a new instance of NotFound
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#160
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# Notifier is useful high-level synchronization primitive.
#
# source://grpc//src/ruby/lib/grpc/notifier.rb#18
class GRPC::Notifier
  # @return [Notifier] a new instance of Notifier
  #
  # source://grpc//src/ruby/lib/grpc/notifier.rb#22
  def initialize; end

  # Returns the value of attribute notified.
  #
  # source://grpc//src/ruby/lib/grpc/notifier.rb#19
  def notified; end

  # Returns the value of attribute notified.
  #
  # source://grpc//src/ruby/lib/grpc/notifier.rb#19
  def notified?; end

  # source://grpc//src/ruby/lib/grpc/notifier.rb#35
  def notify(payload); end

  # Returns the value of attribute payload.
  #
  # source://grpc//src/ruby/lib/grpc/notifier.rb#19
  def payload; end

  # source://grpc//src/ruby/lib/grpc/notifier.rb#29
  def wait; end
end

# GRPC status code corresponding to status OK
#
# source://grpc//src/ruby/lib/grpc/errors.rb#109
class GRPC::Ok < ::GRPC::BadStatus
  # @return [Ok] a new instance of Ok
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#110
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status OUT_OF_RANGE
#
# source://grpc//src/ruby/lib/grpc/errors.rb#229
class GRPC::OutOfRange < ::GRPC::BadStatus
  # @return [OutOfRange] a new instance of OutOfRange
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#230
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status PERMISSION_DENIED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#179
class GRPC::PermissionDenied < ::GRPC::BadStatus
  # @return [PermissionDenied] a new instance of PermissionDenied
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#180
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# Pool is a simple thread pool.
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#23
class GRPC::Pool
  # @return [Pool] a new instance of Pool
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#27
  def initialize(size, keep_alive: T.unsafe(nil)); end

  # Returns the number of jobs waiting
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#43
  def jobs_waiting; end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#47
  def ready_for_work?; end

  # Runs the given block on the queue with the provided args.
  #
  # @param args the args passed blk when it is called
  # @param blk the block to call
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#58
  def schedule(*args, &blk); end

  # Starts running the jobs in the thread pool.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#75
  def start; end

  # Stops the jobs in the pool
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#93
  def stop; end

  protected

  # Forcibly shutdown any threads that are still alive.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#111
  def forcibly_stop_workers; end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#134
  def loop_execute_jobs(worker_queue); end

  # removes the threads from workers, and signal when all the
  # threads are complete.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#127
  def remove_current_thread; end
end

# Default keep alive period is 1s
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#25
GRPC::Pool::DEFAULT_KEEP_ALIVE = T.let(T.unsafe(nil), Integer)

# GRPC status code corresponding to status RESOURCE_EXHAUSTED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#199
class GRPC::ResourceExhausted < ::GRPC::BadStatus
  # @return [ResourceExhausted] a new instance of ResourceExhausted
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#200
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# RpcDesc is a Descriptor of an RPC method.
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#21
class GRPC::RpcDesc < ::Struct
  include ::GRPC::Core::StatusCodes

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#191
  def arity_error(mth, want, msg); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#156
  def assert_arity_matches(mth); end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#187
  def bidi_streamer?; end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#179
  def client_streamer?; end

  # @param active_call [GRPC::ActiveCall]
  # @param mth [Method]
  # @param inter_ctx [Array<GRPC::InterceptionContext>]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#105
  def handle_bidi_streamer(active_call, mth, inter_ctx); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#68
  def handle_client_streamer(active_call, mth, inter_ctx); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#50
  def handle_request_response(active_call, mth, inter_ctx); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#84
  def handle_server_streamer(active_call, mth, inter_ctx); end

  # @return [Proc] { |instance| marshalled(instance) }
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#34
  def marshal_proc; end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#175
  def request_response?; end

  # @param active_call [GRPC::ActiveCall] The current active call object
  #   for the request
  # @param mth [Method] The current RPC method being called
  # @param inter_ctx [GRPC::InterceptionContext] The interception context
  #   being executed
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#117
  def run_server_method(active_call, mth, inter_ctx = T.unsafe(nil)); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#195
  def send_status(active_client, code, details, metadata = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#183
  def server_streamer?; end

  # @param target [:input, :output] determines whether to produce the an
  #   unmarshal Proc for the rpc input parameter or
  #   its output parameter
  # @return [Proc] An unmarshal proc { |marshalled(instance)| instance }
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#43
  def unmarshal_proc(target); end
end

# Used to wrap a message class to indicate that it needs to be streamed.
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#25
class GRPC::RpcDesc::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#28
  def initialize(type); end

  # Returns the value of attribute type.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#26
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_desc.rb#26
  def type=(_arg0); end
end

# RpcServer hosts a number of services and makes them available on the
# network.
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#155
class GRPC::RpcServer
  include ::GRPC::Core::CallOps
  include ::GRPC::Core::TimeConsts
  extend ::Forwardable

  # Creates a new RpcServer.
  #
  # The RPC server is configured using keyword arguments.
  #
  # There are some specific keyword args used to configure the RpcServer
  # instance.
  #
  # * pool_size: the size of the thread pool the server uses to run its
  # threads. No more concurrent requests can be made than the size
  # of the thread pool
  #
  # * max_waiting_requests: Deprecated due to internal changes to the thread
  # pool. This is still an argument for compatibility but is ignored.
  #
  # * poll_period: The amount of time in seconds to wait for
  # currently-serviced RPC's to finish before cancelling them when shutting
  # down the server.
  #
  # * pool_keep_alive: The amount of time in seconds to wait
  # for currently busy thread-pool threads to finish before
  # forcing an abrupt exit to each thread.
  #
  # * connect_md_proc:
  # when non-nil is a proc for determining metadata to send back the client
  # on receiving an invocation req.  The proc signature is:
  #   {key: val, ..} func(method_name, {key: val, ...})
  #
  # * server_args:
  # A server arguments hash to be passed down to the underlying core server
  #
  # * interceptors:
  # An array of GRPC::ServerInterceptor objects that will be used for
  # intercepting server handlers to provide extra functionality.
  # Interceptors are an EXPERIMENTAL API.
  #
  # @return [RpcServer] a new instance of RpcServer
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#217
  def initialize(pool_size: T.unsafe(nil), max_waiting_requests: T.unsafe(nil), poll_period: T.unsafe(nil), pool_keep_alive: T.unsafe(nil), connect_md_proc: T.unsafe(nil), server_args: T.unsafe(nil), interceptors: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def add_http2_port(*args, **_arg1, &block); end

  # Sends RESOURCE_EXHAUSTED if there are too many unprocessed jobs
  #
  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#418
  def available?(an_rpc); end

  # handle registration of classes
  #
  # service is either a class that includes GRPC::GenericService and whose
  # #new function can be called without argument or any instance of such a
  # class.
  #
  # E.g, after
  #
  # class Divider
  #   include GRPC::GenericService
  #   rpc :div DivArgs, DivReply    # single request, single response
  #   def initialize(optional_arg='default option') # no args
  #     ...
  #   end
  #
  # srv = GRPC::RpcServer.new(...)
  #
  # # Either of these works
  #
  # srv.handle(Divider)
  #
  # # or
  #
  # srv.handle(Divider.new('replace optional arg'))
  #
  # It raises RuntimeError:
  # - if service is not valid service class or object
  # - its handler methods are already registered
  # - if the server is already running
  #
  # @param service [Object|Class] a service class or object as described
  #   above
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#333
  def handle(service); end

  # Sends UNIMPLEMENTED if the method is not implemented by this server
  #
  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#433
  def implemented?(an_rpc); end

  # handles calls to the server
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#448
  def loop_handle_server_calls; end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#487
  def new_active_server_call(an_rpc); end

  # runs the server
  #
  # - if no rpc_descs are registered, this exits immediately, otherwise it
  #   continues running permanently and does not return until program exit.
  #
  # - #running? returns true after this is called, until #stop cause the
  #   the server to stop.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#351
  def run; end

  # runs the server
  #
  # - if no rpc_descs are registered, this exits immediately, otherwise it
  #   continues running permanently and does not return until program exit.
  #
  # - #running? returns true after this is called, until #stop cause the
  #   the server to stop.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#351
  def run_till_terminated; end

  # runs the server with signal handlers
  #
  # @param signals List of String, Integer or both representing signals that the user
  #   would like to send to the server for graceful shutdown
  # @param wait_interval [optional] Integer seconds that user would like stop_server_thread to poll
  #   stop_server
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#371
  def run_till_terminated_or_interrupted(signals, wait_interval = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#280
  def running?; end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#260
  def running_state; end

  # stops a running server
  #
  # the call has no impact if the server is already stopped, otherwise
  # server's current call loop is it's last.
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#242
  def stop; end

  # @return [Boolean]
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#284
  def stopped?; end

  # Can only be called while holding @run_mutex
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#267
  def transition_running_state(target_state); end

  # Is called from other threads to wait for #run to start up the server.
  #
  # If run has not been called, this returns immediately.
  #
  # @param timeout [Numeric] number of seconds to wait
  # @return [true, false] true if the server is running, false otherwise
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#294
  def wait_till_running(timeout = T.unsafe(nil)); end

  protected

  # This should be called while holding @run_mutex
  #
  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#534
  def add_rpc_descs_for(service); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#525
  def assert_valid_service_class(cls); end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#517
  def rpc_descs; end

  # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#521
  def rpc_handlers; end

  class << self
    # setup_connect_md_proc is used by #initialize to validate the
    # connect_md_proc.
    #
    # source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#176
    def setup_connect_md_proc(a_proc); end
  end
end

# Deprecated due to internal changes to the thread pool
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#166
GRPC::RpcServer::DEFAULT_MAX_WAITING_REQUESTS = T.let(T.unsafe(nil), Integer)

# Default poll period is 1s
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#169
GRPC::RpcServer::DEFAULT_POLL_PERIOD = T.let(T.unsafe(nil), Integer)

# Default thread pool size is 30
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#163
GRPC::RpcServer::DEFAULT_POOL_SIZE = T.let(T.unsafe(nil), Integer)

# Signal check period is 0.25s
#
# source://grpc//src/ruby/lib/grpc/generic/rpc_server.rb#172
GRPC::RpcServer::SIGNAL_CHECK_PERIOD = T.let(T.unsafe(nil), Float)

# ServerInterceptor allows for wrapping gRPC server execution handling.
# This is an EXPERIMENTAL API.
#
# source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#97
class GRPC::ServerInterceptor < ::GRPC::Interceptor
  # Intercept a BiDi streaming call
  #
  # @param requests [Enumerable<Object>]
  # @param call [GRPC::ActiveCall::MultiReqView]
  # @param method [Method]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#143
  def bidi_streamer(requests: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil)); end

  # Intercept a client streaming call
  #
  # @param call [GRPC::ActiveCall::MultiReqView]
  # @param method [Method]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#117
  def client_streamer(call: T.unsafe(nil), method: T.unsafe(nil)); end

  # Intercept a unary request response call.
  #
  # @param request [Object]
  # @param call [GRPC::ActiveCall::SingleReqView]
  # @param method [Method]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#105
  def request_response(request: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil)); end

  # Intercept a server streaming call
  #
  # @param request [Object]
  # @param call [GRPC::ActiveCall::SingleReqView]
  # @param method [Method]
  #
  # source://grpc//src/ruby/lib/grpc/generic/interceptors.rb#130
  def server_streamer(request: T.unsafe(nil), call: T.unsafe(nil), method: T.unsafe(nil)); end
end

# GRPC status code corresponding to status UNAUTHENTICATED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#189
class GRPC::Unauthenticated < ::GRPC::BadStatus
  # @return [Unauthenticated] a new instance of Unauthenticated
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#190
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status UNAVAILABLE
#
# source://grpc//src/ruby/lib/grpc/errors.rb#259
class GRPC::Unavailable < ::GRPC::BadStatus
  # @return [Unavailable] a new instance of Unavailable
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#260
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status UNIMPLEMENTED
#
# source://grpc//src/ruby/lib/grpc/errors.rb#239
class GRPC::Unimplemented < ::GRPC::BadStatus
  # @return [Unimplemented] a new instance of Unimplemented
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#240
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# GRPC status code corresponding to status UNKNOWN
#
# source://grpc//src/ruby/lib/grpc/errors.rb#129
class GRPC::Unknown < ::GRPC::BadStatus
  # @return [Unknown] a new instance of Unknown
  #
  # source://grpc//src/ruby/lib/grpc/errors.rb#130
  def initialize(details = T.unsafe(nil), metadata = T.unsafe(nil), debug_error_string = T.unsafe(nil)); end
end

# source://grpc//src/ruby/lib/grpc/version.rb#17
GRPC::VERSION = T.let(T.unsafe(nil), String)

# source://grpc//src/ruby/lib/grpc/generic/active_call.rb#19
class Struct
  include ::Enumerable
end

# BatchResult is the struct returned by calls to call#start_batch.
Struct::BatchResult = Struct

Struct::NewServerRpc = Struct

# source://grpc//src/ruby/lib/grpc/structs.rb#15
Struct::Status = Struct
