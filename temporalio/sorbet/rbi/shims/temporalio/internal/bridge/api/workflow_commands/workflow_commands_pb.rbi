# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/sdk/core/workflow_commands/workflow_commands.proto
# typed: strict

class Temporalio::Internal::Bridge::Api::WorkflowCommands::WorkflowCommand
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::WorkflowCommand) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::WorkflowCommand).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::WorkflowCommand) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::WorkflowCommand, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      start_timer: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer),
      schedule_activity: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity),
      respond_to_query: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult),
      request_cancel_activity: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity),
      cancel_timer: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer),
      complete_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution),
      fail_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution),
      continue_as_new_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution),
      cancel_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution),
      set_patch_marker: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker),
      start_child_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution),
      cancel_child_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution),
      request_cancel_external_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution),
      signal_external_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution),
      cancel_signal_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow),
      schedule_local_activity: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity),
      request_cancel_local_activity: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity),
      upsert_workflow_search_attributes: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes),
      modify_workflow_properties: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties),
      update_response: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse)
    ).void
  end
  def initialize(
    start_timer: nil,
    schedule_activity: nil,
    respond_to_query: nil,
    request_cancel_activity: nil,
    cancel_timer: nil,
    complete_workflow_execution: nil,
    fail_workflow_execution: nil,
    continue_as_new_workflow_execution: nil,
    cancel_workflow_execution: nil,
    set_patch_marker: nil,
    start_child_workflow_execution: nil,
    cancel_child_workflow_execution: nil,
    request_cancel_external_workflow_execution: nil,
    signal_external_workflow_execution: nil,
    cancel_signal_workflow: nil,
    schedule_local_activity: nil,
    request_cancel_local_activity: nil,
    upsert_workflow_search_attributes: nil,
    modify_workflow_properties: nil,
    update_response: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer)) }
  def start_timer
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer)).void }
  def start_timer=(value)
  end

  sig { void }
  def clear_start_timer
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity)) }
  def schedule_activity
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity)).void }
  def schedule_activity=(value)
  end

  sig { void }
  def clear_schedule_activity
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult)) }
  def respond_to_query
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult)).void }
  def respond_to_query=(value)
  end

  sig { void }
  def clear_respond_to_query
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity)) }
  def request_cancel_activity
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity)).void }
  def request_cancel_activity=(value)
  end

  sig { void }
  def clear_request_cancel_activity
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer)) }
  def cancel_timer
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer)).void }
  def cancel_timer=(value)
  end

  sig { void }
  def clear_cancel_timer
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution)) }
  def complete_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution)).void }
  def complete_workflow_execution=(value)
  end

  sig { void }
  def clear_complete_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution)) }
  def fail_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution)).void }
  def fail_workflow_execution=(value)
  end

  sig { void }
  def clear_fail_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution)) }
  def continue_as_new_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution)).void }
  def continue_as_new_workflow_execution=(value)
  end

  sig { void }
  def clear_continue_as_new_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution)) }
  def cancel_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution)).void }
  def cancel_workflow_execution=(value)
  end

  sig { void }
  def clear_cancel_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker)) }
  def set_patch_marker
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker)).void }
  def set_patch_marker=(value)
  end

  sig { void }
  def clear_set_patch_marker
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution)) }
  def start_child_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution)).void }
  def start_child_workflow_execution=(value)
  end

  sig { void }
  def clear_start_child_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution)) }
  def cancel_child_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution)).void }
  def cancel_child_workflow_execution=(value)
  end

  sig { void }
  def clear_cancel_child_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution)) }
  def request_cancel_external_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution)).void }
  def request_cancel_external_workflow_execution=(value)
  end

  sig { void }
  def clear_request_cancel_external_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution)) }
  def signal_external_workflow_execution
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution)).void }
  def signal_external_workflow_execution=(value)
  end

  sig { void }
  def clear_signal_external_workflow_execution
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow)) }
  def cancel_signal_workflow
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow)).void }
  def cancel_signal_workflow=(value)
  end

  sig { void }
  def clear_cancel_signal_workflow
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity)) }
  def schedule_local_activity
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity)).void }
  def schedule_local_activity=(value)
  end

  sig { void }
  def clear_schedule_local_activity
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity)) }
  def request_cancel_local_activity
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity)).void }
  def request_cancel_local_activity=(value)
  end

  sig { void }
  def clear_request_cancel_local_activity
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes)) }
  def upsert_workflow_search_attributes
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes)).void }
  def upsert_workflow_search_attributes=(value)
  end

  sig { void }
  def clear_upsert_workflow_search_attributes
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties)) }
  def modify_workflow_properties
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties)).void }
  def modify_workflow_properties=(value)
  end

  sig { void }
  def clear_modify_workflow_properties
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse)) }
  def update_response
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse)).void }
  def update_response=(value)
  end

  sig { void }
  def clear_update_response
  end

  sig { returns(T.nilable(Symbol)) }
  def variant
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::StartTimer, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      start_to_fire_timeout: T.nilable(Google::Protobuf::Duration)
    ).void
  end
  def initialize(
    seq: 0,
    start_to_fire_timeout: nil
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def start_to_fire_timeout
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def start_to_fire_timeout=(value)
  end

  sig { void }
  def clear_start_to_fire_timeout
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelTimer, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    seq: 0
  )
  end

  # Lang's incremental sequence number as passed to `StartTimer`
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number as passed to `StartTimer`
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number as passed to `StartTimer`
  sig { void }
  def clear_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleActivity, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      activity_id: T.nilable(String),
      activity_type: T.nilable(String),
      task_queue: T.nilable(String),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      arguments: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      schedule_to_close_timeout: T.nilable(Google::Protobuf::Duration),
      schedule_to_start_timeout: T.nilable(Google::Protobuf::Duration),
      start_to_close_timeout: T.nilable(Google::Protobuf::Duration),
      heartbeat_timeout: T.nilable(Google::Protobuf::Duration),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      cancellation_type: T.nilable(T.any(Symbol, String, Integer)),
      do_not_eagerly_execute: T.nilable(T::Boolean),
      versioning_intent: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    seq: 0,
    activity_id: "",
    activity_type: "",
    task_queue: "",
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    arguments: [],
    schedule_to_close_timeout: nil,
    schedule_to_start_timeout: nil,
    start_to_close_timeout: nil,
    heartbeat_timeout: nil,
    retry_policy: nil,
    cancellation_type: :TRY_CANCEL,
    do_not_eagerly_execute: false,
    versioning_intent: :UNSPECIFIED
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  sig { returns(String) }
  def activity_id
  end

  sig { params(value: String).void }
  def activity_id=(value)
  end

  sig { void }
  def clear_activity_id
  end

  sig { returns(String) }
  def activity_type
  end

  sig { params(value: String).void }
  def activity_type=(value)
  end

  sig { void }
  def clear_activity_type
  end

  # The name of the task queue to place this activity request in
  sig { returns(String) }
  def task_queue
  end

  # The name of the task queue to place this activity request in
  sig { params(value: String).void }
  def task_queue=(value)
  end

  # The name of the task queue to place this activity request in
  sig { void }
  def clear_task_queue
  end

  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  sig { void }
  def clear_headers
  end

  # Arguments/input to the activity. Called "input" upstream.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def arguments
  end

  # Arguments/input to the activity. Called "input" upstream.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def arguments=(value)
  end

  # Arguments/input to the activity. Called "input" upstream.
  sig { void }
  def clear_arguments
  end

  # Indicates how long the caller is willing to wait for an activity completion. Limits how long
# retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
# When not specified defaults to the workflow execution timeout.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_close_timeout
  end

  # Indicates how long the caller is willing to wait for an activity completion. Limits how long
# retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
# When not specified defaults to the workflow execution timeout.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_close_timeout=(value)
  end

  # Indicates how long the caller is willing to wait for an activity completion. Limits how long
# retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
# When not specified defaults to the workflow execution timeout.
  sig { void }
  def clear_schedule_to_close_timeout
  end

  # Limits time an activity task can stay in a task queue before a worker picks it up. This
# timeout is always non retryable as all a retry would achieve is to put it back into the same
# queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_start_timeout
  end

  # Limits time an activity task can stay in a task queue before a worker picks it up. This
# timeout is always non retryable as all a retry would achieve is to put it back into the same
# queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_start_timeout=(value)
  end

  # Limits time an activity task can stay in a task queue before a worker picks it up. This
# timeout is always non retryable as all a retry would achieve is to put it back into the same
# queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
  sig { void }
  def clear_schedule_to_start_timeout
  end

  # Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
# always retryable. Either this or schedule_to_close_timeout must be specified.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def start_to_close_timeout
  end

  # Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
# always retryable. Either this or schedule_to_close_timeout must be specified.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def start_to_close_timeout=(value)
  end

  # Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
# always retryable. Either this or schedule_to_close_timeout must be specified.
  sig { void }
  def clear_start_to_close_timeout
  end

  # Maximum time allowed between successful worker heartbeats.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def heartbeat_timeout
  end

  # Maximum time allowed between successful worker heartbeats.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def heartbeat_timeout=(value)
  end

  # Maximum time allowed between successful worker heartbeats.
  sig { void }
  def clear_heartbeat_timeout
  end

  # Activities are provided by a default retry policy controlled through the service dynamic
# configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
# retry_policy.maximum_attempts to 1.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  # Activities are provided by a default retry policy controlled through the service dynamic
# configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
# retry_policy.maximum_attempts to 1.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  # Activities are provided by a default retry policy controlled through the service dynamic
# configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
# retry_policy.maximum_attempts to 1.
  sig { void }
  def clear_retry_policy
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
  sig { returns(T.any(Symbol, Integer)) }
  def cancellation_type
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def cancellation_type=(value)
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
  sig { void }
  def clear_cancellation_type
  end

  # If set, the worker will not tell the service that it can immediately start executing this
# activity. When unset/default, workers will always attempt to do so if activity execution
# slots are available.
  sig { returns(T::Boolean) }
  def do_not_eagerly_execute
  end

  # If set, the worker will not tell the service that it can immediately start executing this
# activity. When unset/default, workers will always attempt to do so if activity execution
# slots are available.
  sig { params(value: T::Boolean).void }
  def do_not_eagerly_execute=(value)
  end

  # If set, the worker will not tell the service that it can immediately start executing this
# activity. When unset/default, workers will always attempt to do so if activity execution
# slots are available.
  sig { void }
  def clear_do_not_eagerly_execute
  end

  # Whether this activity should run on a worker with a compatible build id or not.
  sig { returns(T.any(Symbol, Integer)) }
  def versioning_intent
  end

  # Whether this activity should run on a worker with a compatible build id or not.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def versioning_intent=(value)
  end

  # Whether this activity should run on a worker with a compatible build id or not.
  sig { void }
  def clear_versioning_intent
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ScheduleLocalActivity, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      activity_id: T.nilable(String),
      activity_type: T.nilable(String),
      attempt: T.nilable(Integer),
      original_schedule_time: T.nilable(Google::Protobuf::Timestamp),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      arguments: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      schedule_to_close_timeout: T.nilable(Google::Protobuf::Duration),
      schedule_to_start_timeout: T.nilable(Google::Protobuf::Duration),
      start_to_close_timeout: T.nilable(Google::Protobuf::Duration),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      local_retry_threshold: T.nilable(Google::Protobuf::Duration),
      cancellation_type: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    seq: 0,
    activity_id: "",
    activity_type: "",
    attempt: 0,
    original_schedule_time: nil,
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    arguments: [],
    schedule_to_close_timeout: nil,
    schedule_to_start_timeout: nil,
    start_to_close_timeout: nil,
    retry_policy: nil,
    local_retry_threshold: nil,
    cancellation_type: :TRY_CANCEL
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  sig { returns(String) }
  def activity_id
  end

  sig { params(value: String).void }
  def activity_id=(value)
  end

  sig { void }
  def clear_activity_id
  end

  sig { returns(String) }
  def activity_type
  end

  sig { params(value: String).void }
  def activity_type=(value)
  end

  sig { void }
  def clear_activity_type
  end

  # Local activities can start with a non-1 attempt, if lang has been told to backoff using
# a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
# resolution.
  sig { returns(Integer) }
  def attempt
  end

  # Local activities can start with a non-1 attempt, if lang has been told to backoff using
# a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
# resolution.
  sig { params(value: Integer).void }
  def attempt=(value)
  end

  # Local activities can start with a non-1 attempt, if lang has been told to backoff using
# a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
# resolution.
  sig { void }
  def clear_attempt
  end

  # If this local activity is a retry (as per the attempt field) this needs to be the original
# scheduling time (as provided in `DoBackoff`)
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def original_schedule_time
  end

  # If this local activity is a retry (as per the attempt field) this needs to be the original
# scheduling time (as provided in `DoBackoff`)
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def original_schedule_time=(value)
  end

  # If this local activity is a retry (as per the attempt field) this needs to be the original
# scheduling time (as provided in `DoBackoff`)
  sig { void }
  def clear_original_schedule_time
  end

  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  sig { void }
  def clear_headers
  end

  # Arguments/input to the activity.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def arguments
  end

  # Arguments/input to the activity.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def arguments=(value)
  end

  # Arguments/input to the activity.
  sig { void }
  def clear_arguments
  end

  # Indicates how long the caller is willing to wait for local activity completion. Limits how
# long retries will be attempted. When not specified defaults to the workflow execution
# timeout (which may be unset).
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_close_timeout
  end

  # Indicates how long the caller is willing to wait for local activity completion. Limits how
# long retries will be attempted. When not specified defaults to the workflow execution
# timeout (which may be unset).
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_close_timeout=(value)
  end

  # Indicates how long the caller is willing to wait for local activity completion. Limits how
# long retries will be attempted. When not specified defaults to the workflow execution
# timeout (which may be unset).
  sig { void }
  def clear_schedule_to_close_timeout
  end

  # Limits time the local activity can idle internally before being executed. That can happen if
# the worker is currently at max concurrent local activity executions. This timeout is always
# non retryable as all a retry would achieve is to put it back into the same queue. Defaults
# to `schedule_to_close_timeout` if not specified and that is set. Must be <=
# `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_start_timeout
  end

  # Limits time the local activity can idle internally before being executed. That can happen if
# the worker is currently at max concurrent local activity executions. This timeout is always
# non retryable as all a retry would achieve is to put it back into the same queue. Defaults
# to `schedule_to_close_timeout` if not specified and that is set. Must be <=
# `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_start_timeout=(value)
  end

  # Limits time the local activity can idle internally before being executed. That can happen if
# the worker is currently at max concurrent local activity executions. This timeout is always
# non retryable as all a retry would achieve is to put it back into the same queue. Defaults
# to `schedule_to_close_timeout` if not specified and that is set. Must be <=
# `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
  sig { void }
  def clear_schedule_to_start_timeout
  end

  # Maximum time the local activity is allowed to execute after the task is dispatched. This
# timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
# specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
# clamped down.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def start_to_close_timeout
  end

  # Maximum time the local activity is allowed to execute after the task is dispatched. This
# timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
# specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
# clamped down.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def start_to_close_timeout=(value)
  end

  # Maximum time the local activity is allowed to execute after the task is dispatched. This
# timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
# specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
# clamped down.
  sig { void }
  def clear_start_to_close_timeout
  end

  # Specify a retry policy for the local activity. By default local activities will be retried
# indefinitely.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  # Specify a retry policy for the local activity. By default local activities will be retried
# indefinitely.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  # Specify a retry policy for the local activity. By default local activities will be retried
# indefinitely.
  sig { void }
  def clear_retry_policy
  end

  # If the activity is retrying and backoff would exceed this value, lang will be told to
# schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
# core. Defaults to 1 minute.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def local_retry_threshold
  end

  # If the activity is retrying and backoff would exceed this value, lang will be told to
# schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
# core. Defaults to 1 minute.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def local_retry_threshold=(value)
  end

  # If the activity is retrying and backoff would exceed this value, lang will be told to
# schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
# core. Defaults to 1 minute.
  sig { void }
  def clear_local_retry_threshold
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be
# confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
# will default to `TRY_CANCEL` automatically.
  sig { returns(T.any(Symbol, Integer)) }
  def cancellation_type
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be
# confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
# will default to `TRY_CANCEL` automatically.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def cancellation_type=(value)
  end

  # Defines how the workflow will wait (or not) for cancellation of the activity to be
# confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
# will default to `TRY_CANCEL` automatically.
  sig { void }
  def clear_cancellation_type
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelActivity, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    seq: 0
  )
  end

  # Lang's incremental sequence number as passed to `ScheduleActivity`
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number as passed to `ScheduleActivity`
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number as passed to `ScheduleActivity`
  sig { void }
  def clear_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelLocalActivity, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    seq: 0
  )
  end

  # Lang's incremental sequence number as passed to `ScheduleLocalActivity`
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number as passed to `ScheduleLocalActivity`
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number as passed to `ScheduleLocalActivity`
  sig { void }
  def clear_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::QueryResult, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      query_id: T.nilable(String),
      succeeded: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess),
      failed: T.nilable(Temporalio::Api::Failure::V1::Failure)
    ).void
  end
  def initialize(
    query_id: "",
    succeeded: nil,
    failed: nil
  )
  end

  # Corresponds to the id provided in the activation job
  sig { returns(String) }
  def query_id
  end

  # Corresponds to the id provided in the activation job
  sig { params(value: String).void }
  def query_id=(value)
  end

  # Corresponds to the id provided in the activation job
  sig { void }
  def clear_query_id
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess)) }
  def succeeded
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess)).void }
  def succeeded=(value)
  end

  sig { void }
  def clear_succeeded
  end

  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def failed
  end

  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def failed=(value)
  end

  sig { void }
  def clear_failed
  end

  sig { returns(T.nilable(Symbol)) }
  def variant
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::QuerySuccess, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      response: T.nilable(Temporalio::Api::Common::V1::Payload)
    ).void
  end
  def initialize(
    response: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payload)) }
  def response
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payload)).void }
  def response=(value)
  end

  sig { void }
  def clear_response
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Issued when the workflow completes successfully
class Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CompleteWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      result: T.nilable(Temporalio::Api::Common::V1::Payload)
    ).void
  end
  def initialize(
    result: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payload)) }
  def result
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payload)).void }
  def result=(value)
  end

  sig { void }
  def clear_result
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Issued when the workflow errors out
class Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::FailWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      failure: T.nilable(Temporalio::Api::Failure::V1::Failure)
    ).void
  end
  def initialize(
    failure: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def failure
  end

  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def failure=(value)
  end

  sig { void }
  def clear_failure
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Continue the workflow as a new execution
class Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ContinueAsNewWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_type: T.nilable(String),
      task_queue: T.nilable(String),
      arguments: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      workflow_run_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_task_timeout: T.nilable(Google::Protobuf::Duration),
      memo: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      search_attributes: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      versioning_intent: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    workflow_type: "",
    task_queue: "",
    arguments: [],
    workflow_run_timeout: nil,
    workflow_task_timeout: nil,
    memo: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    search_attributes: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    retry_policy: nil,
    versioning_intent: :UNSPECIFIED
  )
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { returns(String) }
  def workflow_type
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { params(value: String).void }
  def workflow_type=(value)
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { void }
  def clear_workflow_type
  end

  # Task queue for the new workflow execution
  sig { returns(String) }
  def task_queue
  end

  # Task queue for the new workflow execution
  sig { params(value: String).void }
  def task_queue=(value)
  end

  # Task queue for the new workflow execution
  sig { void }
  def clear_task_queue
  end

  # Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
# typically wouldn't make any sense.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def arguments
  end

  # Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
# typically wouldn't make any sense.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def arguments=(value)
  end

  # Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
# typically wouldn't make any sense.
  sig { void }
  def clear_arguments
  end

  # Timeout for a single run of the new workflow. Will not re-use current workflow's value.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_run_timeout
  end

  # Timeout for a single run of the new workflow. Will not re-use current workflow's value.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_run_timeout=(value)
  end

  # Timeout for a single run of the new workflow. Will not re-use current workflow's value.
  sig { void }
  def clear_workflow_run_timeout
  end

  # Timeout of a single workflow task. Will not re-use current workflow's value.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_task_timeout
  end

  # Timeout of a single workflow task. Will not re-use current workflow's value.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_task_timeout=(value)
  end

  # Timeout of a single workflow task. Will not re-use current workflow's value.
  sig { void }
  def clear_workflow_task_timeout
  end

  # If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def memo
  end

  # If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
  sig { params(value: ::Google::Protobuf::Map).void }
  def memo=(value)
  end

  # If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
  sig { void }
  def clear_memo
  end

  # If set, the new workflow will have these headers. Will *not* re-use current workflow's
# headers otherwise.
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # If set, the new workflow will have these headers. Will *not* re-use current workflow's
# headers otherwise.
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # If set, the new workflow will have these headers. Will *not* re-use current workflow's
# headers otherwise.
  sig { void }
  def clear_headers
  end

  # If set, the new workflow will have these search attributes. If unset, re-uses the current
# workflow's search attributes.
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def search_attributes
  end

  # If set, the new workflow will have these search attributes. If unset, re-uses the current
# workflow's search attributes.
  sig { params(value: ::Google::Protobuf::Map).void }
  def search_attributes=(value)
  end

  # If set, the new workflow will have these search attributes. If unset, re-uses the current
# workflow's search attributes.
  sig { void }
  def clear_search_attributes
  end

  # If set, the new workflow will have this retry policy. If unset, re-uses the current
# workflow's retry policy.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  # If set, the new workflow will have this retry policy. If unset, re-uses the current
# workflow's retry policy.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  # If set, the new workflow will have this retry policy. If unset, re-uses the current
# workflow's retry policy.
  sig { void }
  def clear_retry_policy
  end

  # Whether the continued workflow should run on a worker with a compatible build id or not.
  sig { returns(T.any(Symbol, Integer)) }
  def versioning_intent
  end

  # Whether the continued workflow should run on a worker with a compatible build id or not.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def versioning_intent=(value)
  end

  # Whether the continued workflow should run on a worker with a compatible build id or not.
  sig { void }
  def clear_versioning_intent
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Indicate a workflow has completed as cancelled. Generally sent as a response to an activation
# containing a cancellation job.
class Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig {void}
  def initialize; end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# A request to set/check if a certain patch is present or not
class Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::SetPatchMarker, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      patch_id: T.nilable(String),
      deprecated: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    patch_id: "",
    deprecated: false
  )
  end

  # A user-chosen identifier for this patch. If the same identifier is used in multiple places in
# the code, those places are considered to be versioned as one unit. IE: The check call will
# return the same result for all of them
  sig { returns(String) }
  def patch_id
  end

  # A user-chosen identifier for this patch. If the same identifier is used in multiple places in
# the code, those places are considered to be versioned as one unit. IE: The check call will
# return the same result for all of them
  sig { params(value: String).void }
  def patch_id=(value)
  end

  # A user-chosen identifier for this patch. If the same identifier is used in multiple places in
# the code, those places are considered to be versioned as one unit. IE: The check call will
# return the same result for all of them
  sig { void }
  def clear_patch_id
  end

  # Can be set to true to indicate that branches using this change are being removed, and all
# future worker deployments will only have the "with change" code in them.
  sig { returns(T::Boolean) }
  def deprecated
  end

  # Can be set to true to indicate that branches using this change are being removed, and all
# future worker deployments will only have the "with change" code in them.
  sig { params(value: T::Boolean).void }
  def deprecated=(value)
  end

  # Can be set to true to indicate that branches using this change are being removed, and all
# future worker deployments will only have the "with change" code in them.
  sig { void }
  def clear_deprecated
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Start a child workflow execution
class Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::StartChildWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      namespace: T.nilable(String),
      workflow_id: T.nilable(String),
      workflow_type: T.nilable(String),
      task_queue: T.nilable(String),
      input: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      workflow_execution_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_run_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_task_timeout: T.nilable(Google::Protobuf::Duration),
      parent_close_policy: T.nilable(T.any(Symbol, String, Integer)),
      workflow_id_reuse_policy: T.nilable(T.any(Symbol, String, Integer)),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      cron_schedule: T.nilable(String),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      memo: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      search_attributes: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      cancellation_type: T.nilable(T.any(Symbol, String, Integer)),
      versioning_intent: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    seq: 0,
    namespace: "",
    workflow_id: "",
    workflow_type: "",
    task_queue: "",
    input: [],
    workflow_execution_timeout: nil,
    workflow_run_timeout: nil,
    workflow_task_timeout: nil,
    parent_close_policy: :PARENT_CLOSE_POLICY_UNSPECIFIED,
    workflow_id_reuse_policy: :WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED,
    retry_policy: nil,
    cron_schedule: "",
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    memo: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    search_attributes: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    cancellation_type: :ABANDON,
    versioning_intent: :UNSPECIFIED
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  sig { returns(String) }
  def namespace
  end

  sig { params(value: String).void }
  def namespace=(value)
  end

  sig { void }
  def clear_namespace
  end

  sig { returns(String) }
  def workflow_id
  end

  sig { params(value: String).void }
  def workflow_id=(value)
  end

  sig { void }
  def clear_workflow_id
  end

  sig { returns(String) }
  def workflow_type
  end

  sig { params(value: String).void }
  def workflow_type=(value)
  end

  sig { void }
  def clear_workflow_type
  end

  sig { returns(String) }
  def task_queue
  end

  sig { params(value: String).void }
  def task_queue=(value)
  end

  sig { void }
  def clear_task_queue
  end

  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def input
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def input=(value)
  end

  sig { void }
  def clear_input
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_execution_timeout
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_execution_timeout=(value)
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { void }
  def clear_workflow_execution_timeout
  end

  # Timeout of a single workflow run.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_run_timeout
  end

  # Timeout of a single workflow run.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_run_timeout=(value)
  end

  # Timeout of a single workflow run.
  sig { void }
  def clear_workflow_run_timeout
  end

  # Timeout of a single workflow task.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_task_timeout
  end

  # Timeout of a single workflow task.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_task_timeout=(value)
  end

  # Timeout of a single workflow task.
  sig { void }
  def clear_workflow_task_timeout
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { returns(T.any(Symbol, Integer)) }
  def parent_close_policy
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def parent_close_policy=(value)
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { void }
  def clear_parent_close_policy
  end

  # string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
# Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { returns(T.any(Symbol, Integer)) }
  def workflow_id_reuse_policy
  end

  # string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
# Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def workflow_id_reuse_policy=(value)
  end

  # string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
# Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { void }
  def clear_workflow_id_reuse_policy
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  sig { void }
  def clear_retry_policy
  end

  sig { returns(String) }
  def cron_schedule
  end

  sig { params(value: String).void }
  def cron_schedule=(value)
  end

  sig { void }
  def clear_cron_schedule
  end

  # Header fields
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Header fields
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Header fields
  sig { void }
  def clear_headers
  end

  # Memo fields
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def memo
  end

  # Memo fields
  sig { params(value: ::Google::Protobuf::Map).void }
  def memo=(value)
  end

  # Memo fields
  sig { void }
  def clear_memo
  end

  # Search attributes
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def search_attributes
  end

  # Search attributes
  sig { params(value: ::Google::Protobuf::Map).void }
  def search_attributes=(value)
  end

  # Search attributes
  sig { void }
  def clear_search_attributes
  end

  # Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
  sig { returns(T.any(Symbol, Integer)) }
  def cancellation_type
  end

  # Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def cancellation_type=(value)
  end

  # Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
  sig { void }
  def clear_cancellation_type
  end

  # Whether this child should run on a worker with a compatible build id or not.
  sig { returns(T.any(Symbol, Integer)) }
  def versioning_intent
  end

  # Whether this child should run on a worker with a compatible build id or not.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def versioning_intent=(value)
  end

  # Whether this child should run on a worker with a compatible build id or not.
  sig { void }
  def clear_versioning_intent
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Cancel a child workflow
class Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelChildWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      child_workflow_seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    child_workflow_seq: 0
  )
  end

  # Sequence number as given to the `StartChildWorkflowExecution` command
  sig { returns(Integer) }
  def child_workflow_seq
  end

  # Sequence number as given to the `StartChildWorkflowExecution` command
  sig { params(value: Integer).void }
  def child_workflow_seq=(value)
  end

  # Sequence number as given to the `StartChildWorkflowExecution` command
  sig { void }
  def clear_child_workflow_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Request cancellation of an external workflow execution (which may be a started child)
class Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::RequestCancelExternalWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution),
      child_workflow_id: T.nilable(String)
    ).void
  end
  def initialize(
    seq: 0,
    workflow_execution: nil,
    child_workflow_id: ""
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  # A specific workflow instance
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)) }
  def workflow_execution
  end

  # A specific workflow instance
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)).void }
  def workflow_execution=(value)
  end

  # A specific workflow instance
  sig { void }
  def clear_workflow_execution
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { returns(String) }
  def child_workflow_id
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { params(value: String).void }
  def child_workflow_id=(value)
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { void }
  def clear_child_workflow_id
  end

  sig { returns(T.nilable(Symbol)) }
  def target
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Send a signal to an external or child workflow
class Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::SignalExternalWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution),
      child_workflow_id: T.nilable(String),
      signal_name: T.nilable(String),
      args: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)])
    ).void
  end
  def initialize(
    seq: 0,
    workflow_execution: nil,
    child_workflow_id: "",
    signal_name: "",
    args: [],
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload)
  )
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number, used as the operation identifier
  sig { void }
  def clear_seq
  end

  # A specific workflow instance
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)) }
  def workflow_execution
  end

  # A specific workflow instance
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)).void }
  def workflow_execution=(value)
  end

  # A specific workflow instance
  sig { void }
  def clear_workflow_execution
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { returns(String) }
  def child_workflow_id
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { params(value: String).void }
  def child_workflow_id=(value)
  end

  # The desired target must be a child of the issuing workflow, and this is its workflow id
  sig { void }
  def clear_child_workflow_id
  end

  # Name of the signal handler
  sig { returns(String) }
  def signal_name
  end

  # Name of the signal handler
  sig { params(value: String).void }
  def signal_name=(value)
  end

  # Name of the signal handler
  sig { void }
  def clear_signal_name
  end

  # Arguments for the handler
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def args
  end

  # Arguments for the handler
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def args=(value)
  end

  # Arguments for the handler
  sig { void }
  def clear_args
  end

  # Headers to attach to the signal
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Headers to attach to the signal
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Headers to attach to the signal
  sig { void }
  def clear_headers
  end

  sig { returns(T.nilable(Symbol)) }
  def target
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Can be used to cancel not-already-sent `SignalExternalWorkflowExecution` commands
class Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::CancelSignalWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    seq: 0
  )
  end

  # Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`
  sig { returns(Integer) }
  def seq
  end

  # Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`
  sig { void }
  def clear_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::UpsertWorkflowSearchAttributes, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      search_attributes: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)])
    ).void
  end
  def initialize(
    search_attributes: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload)
  )
  end

  # SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
# value?
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def search_attributes
  end

  # SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
# value?
  sig { params(value: ::Google::Protobuf::Map).void }
  def search_attributes=(value)
  end

  # SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
# value?
  sig { void }
  def clear_search_attributes
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::ModifyWorkflowProperties, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      upserted_memo: T.nilable(Temporalio::Api::Common::V1::Memo)
    ).void
  end
  def initialize(
    upserted_memo: nil
  )
  end

  # If set, update the workflow memo with the provided values. The values will be merged with
# the existing memo. If the user wants to delete values, a default/empty Payload should be
# used as the value for the key being deleted.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Memo)) }
  def upserted_memo
  end

  # If set, update the workflow memo with the provided values. The values will be merged with
# the existing memo. If the user wants to delete values, a default/empty Payload should be
# used as the value for the key being deleted.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Memo)).void }
  def upserted_memo=(value)
  end

  # If set, update the workflow memo with the provided values. The values will be merged with
# the existing memo. If the user wants to delete values, a default/empty Payload should be
# used as the value for the key being deleted.
  sig { void }
  def clear_upserted_memo
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# A reply to a `DoUpdate` job - lang must run the update's validator if told to, and then
# immediately run the handler, if the update was accepted.
#
# There must always be an accepted or rejected response immediately, in the same activation as
# this job, to indicate the result of the validator. Accepted for ran and accepted or skipped, or
# rejected for rejected.
#
# Then, in the same or any subsequent activation, after the update handler has completed, respond
# with completed or rejected as appropriate for the result of the handler.
class Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowCommands::UpdateResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      protocol_instance_id: T.nilable(String),
      accepted: T.nilable(Google::Protobuf::Empty),
      rejected: T.nilable(Temporalio::Api::Failure::V1::Failure),
      completed: T.nilable(Temporalio::Api::Common::V1::Payload)
    ).void
  end
  def initialize(
    protocol_instance_id: "",
    accepted: nil,
    rejected: nil,
    completed: nil
  )
  end

  # The protocol message instance ID
  sig { returns(String) }
  def protocol_instance_id
  end

  # The protocol message instance ID
  sig { params(value: String).void }
  def protocol_instance_id=(value)
  end

  # The protocol message instance ID
  sig { void }
  def clear_protocol_instance_id
  end

  # Must be sent if the update's validator has passed (or lang was not asked to run it, and
# thus should be considered already-accepted, allowing lang to always send the same
# sequence on replay).
  sig { returns(T.nilable(Google::Protobuf::Empty)) }
  def accepted
  end

  # Must be sent if the update's validator has passed (or lang was not asked to run it, and
# thus should be considered already-accepted, allowing lang to always send the same
# sequence on replay).
  sig { params(value: T.nilable(Google::Protobuf::Empty)).void }
  def accepted=(value)
  end

  # Must be sent if the update's validator has passed (or lang was not asked to run it, and
# thus should be considered already-accepted, allowing lang to always send the same
# sequence on replay).
  sig { void }
  def clear_accepted
  end

  # Must be sent if the update's validator does not pass, or after acceptance if the update
# handler fails.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def rejected
  end

  # Must be sent if the update's validator does not pass, or after acceptance if the update
# handler fails.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def rejected=(value)
  end

  # Must be sent if the update's validator does not pass, or after acceptance if the update
# handler fails.
  sig { void }
  def clear_rejected
  end

  # Must be sent once the update handler completes successfully.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payload)) }
  def completed
  end

  # Must be sent once the update handler completes successfully.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payload)).void }
  def completed=(value)
  end

  # Must be sent once the update handler completes successfully.
  sig { void }
  def clear_completed
  end

  sig { returns(T.nilable(Symbol)) }
  def response
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

module Temporalio::Internal::Bridge::Api::WorkflowCommands::ActivityCancellationType
  self::TRY_CANCEL = T.let(0, Integer)
  self::WAIT_CANCELLATION_COMPLETED = T.let(1, Integer)
  self::ABANDON = T.let(2, Integer)

  sig { params(value: Integer).returns(T.nilable(Symbol)) }
  def self.lookup(value)
  end

  sig { params(value: Symbol).returns(T.nilable(Integer)) }
  def self.resolve(value)
  end

  sig { returns(::Google::Protobuf::EnumDescriptor) }
  def self.descriptor
  end
end
