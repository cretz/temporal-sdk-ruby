# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/sdk/core/workflow_activation/workflow_activation.proto
# typed: strict

# An instruction to the lang sdk to run some workflow code, whether for the first time or from
# a cached state.
#
# ## Job ordering guarantees and semantics
#
# Core will, by default, order jobs within the activation as follows:
# 1. init workflow
# 2. patches
# 3. random-seed-updates
# 4. signals/updates
# 5. all others
# 6. local activity resolutions
# 7. queries
# 8. evictions
#
# This is because:
# * Patches are expected to apply to the entire activation
# * Signal and update handlers should be invoked before workflow routines are iterated. That is to
#   say before the users' main workflow function and anything spawned by it is allowed to continue.
# * Local activities resolutions go after other normal jobs because while *not* replaying, they
#   will always take longer than anything else that produces an immediate job (which is
#   effectively instant). When *replaying* we need to scan ahead for LA markers so that we can
#   resolve them in the same activation that they completed in when not replaying. However, doing
#   so would, by default, put those resolutions *before* any other immediate jobs that happened
#   in that same activation (prime example: cancelling not-wait-for-cancel activities). So, we do
#   this to ensure the LA resolution happens after that cancel (or whatever else it may be) as it
#   normally would have when executing.
# * Queries always go last (and, in fact, always come in their own activation)
# * Evictions also always come in their own activation
#
# Core does this reordering to ensure that langs observe jobs in the same order during replay as
# they would have during execution. However, in principle, this ordering is not necessary
# (excepting queries/evictions, which definitely must come last) if lang layers apply all jobs to
# state *first* (by resolving promises/futures, marking handlers to be invoked, etc as they iterate
# over the jobs) and then only *after* that is done, drive coroutines/threads/whatever. If
# execution works this way, then determinism is only impacted by the order routines are driven in
# (which must be stable based on lang implementation or convention), rather than the order jobs are
# processed.
#
# ## Evictions
#
# Evictions appear as an activations that contains only a `remove_from_cache` job. Such activations
# should not cause the workflow code to be invoked and may be responded to with an empty command
# list.
class Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivation) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivation).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivation) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivation, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      run_id: T.nilable(String),
      timestamp: T.nilable(Google::Protobuf::Timestamp),
      is_replaying: T.nilable(T::Boolean),
      history_length: T.nilable(Integer),
      jobs: T.nilable(T::Array[T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob)]),
      available_internal_flags: T.nilable(T::Array[Integer]),
      history_size_bytes: T.nilable(Integer),
      continue_as_new_suggested: T.nilable(T::Boolean),
      build_id_for_current_task: T.nilable(String)
    ).void
  end
  def initialize(
    run_id: "",
    timestamp: nil,
    is_replaying: false,
    history_length: 0,
    jobs: [],
    available_internal_flags: [],
    history_size_bytes: 0,
    continue_as_new_suggested: false,
    build_id_for_current_task: ""
  )
  end

  # The id of the currently active run of the workflow. Also used as a cache key. There may
# only ever be one active workflow task (and hence activation) of a run at one time.
  sig { returns(String) }
  def run_id
  end

  # The id of the currently active run of the workflow. Also used as a cache key. There may
# only ever be one active workflow task (and hence activation) of a run at one time.
  sig { params(value: String).void }
  def run_id=(value)
  end

  # The id of the currently active run of the workflow. Also used as a cache key. There may
# only ever be one active workflow task (and hence activation) of a run at one time.
  sig { void }
  def clear_run_id
  end

  # The current time as understood by the workflow, which is set by workflow task started events
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def timestamp
  end

  # The current time as understood by the workflow, which is set by workflow task started events
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def timestamp=(value)
  end

  # The current time as understood by the workflow, which is set by workflow task started events
  sig { void }
  def clear_timestamp
  end

  # Whether or not the activation is replaying past events
  sig { returns(T::Boolean) }
  def is_replaying
  end

  # Whether or not the activation is replaying past events
  sig { params(value: T::Boolean).void }
  def is_replaying=(value)
  end

  # Whether or not the activation is replaying past events
  sig { void }
  def clear_is_replaying
  end

  # Current history length as determined by the event id of the most recently processed event.
# This ensures that the number is always deterministic
  sig { returns(Integer) }
  def history_length
  end

  # Current history length as determined by the event id of the most recently processed event.
# This ensures that the number is always deterministic
  sig { params(value: Integer).void }
  def history_length=(value)
  end

  # Current history length as determined by the event id of the most recently processed event.
# This ensures that the number is always deterministic
  sig { void }
  def clear_history_length
  end

  # The things to do upon activating the workflow
  sig { returns(T::Array[T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob)]) }
  def jobs
  end

  # The things to do upon activating the workflow
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def jobs=(value)
  end

  # The things to do upon activating the workflow
  sig { void }
  def clear_jobs
  end

  # Internal flags which are available for use by lang. If `is_replaying` is false, all
# internal flags may be used. This is not a delta - all previously used flags always
# appear since this representation is cheap.
  sig { returns(T::Array[Integer]) }
  def available_internal_flags
  end

  # Internal flags which are available for use by lang. If `is_replaying` is false, all
# internal flags may be used. This is not a delta - all previously used flags always
# appear since this representation is cheap.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def available_internal_flags=(value)
  end

  # Internal flags which are available for use by lang. If `is_replaying` is false, all
# internal flags may be used. This is not a delta - all previously used flags always
# appear since this representation is cheap.
  sig { void }
  def clear_available_internal_flags
  end

  # The history size in bytes as of the last WFT started event
  sig { returns(Integer) }
  def history_size_bytes
  end

  # The history size in bytes as of the last WFT started event
  sig { params(value: Integer).void }
  def history_size_bytes=(value)
  end

  # The history size in bytes as of the last WFT started event
  sig { void }
  def clear_history_size_bytes
  end

  # Set true if the most recent WFT started event had this suggestion
  sig { returns(T::Boolean) }
  def continue_as_new_suggested
  end

  # Set true if the most recent WFT started event had this suggestion
  sig { params(value: T::Boolean).void }
  def continue_as_new_suggested=(value)
  end

  # Set true if the most recent WFT started event had this suggestion
  sig { void }
  def clear_continue_as_new_suggested
  end

  # Set to the Build ID of the worker that processed this task, which may be empty. During replay
# this id may not equal the id of the replaying worker. If not replaying and this worker has
# a defined Build ID, it will equal that ID. It will also be empty for evict-only activations.
  sig { returns(String) }
  def build_id_for_current_task
  end

  # Set to the Build ID of the worker that processed this task, which may be empty. During replay
# this id may not equal the id of the replaying worker. If not replaying and this worker has
# a defined Build ID, it will equal that ID. It will also be empty for evict-only activations.
  sig { params(value: String).void }
  def build_id_for_current_task=(value)
  end

  # Set to the Build ID of the worker that processed this task, which may be empty. During replay
# this id may not equal the id of the replaying worker. If not replaying and this worker has
# a defined Build ID, it will equal that ID. It will also be empty for evict-only activations.
  sig { void }
  def clear_build_id_for_current_task
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::WorkflowActivationJob, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      initialize_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow),
      fire_timer: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer),
      update_random_seed: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed),
      query_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow),
      cancel_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow),
      signal_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow),
      resolve_activity: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity),
      notify_has_patch: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch),
      resolve_child_workflow_execution_start: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart),
      resolve_child_workflow_execution: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution),
      resolve_signal_external_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow),
      resolve_request_cancel_external_workflow: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow),
      do_update: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate),
      remove_from_cache: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache)
    ).void
  end
  def initialize(
    initialize_workflow: nil,
    fire_timer: nil,
    update_random_seed: nil,
    query_workflow: nil,
    cancel_workflow: nil,
    signal_workflow: nil,
    resolve_activity: nil,
    notify_has_patch: nil,
    resolve_child_workflow_execution_start: nil,
    resolve_child_workflow_execution: nil,
    resolve_signal_external_workflow: nil,
    resolve_request_cancel_external_workflow: nil,
    do_update: nil,
    remove_from_cache: nil
  )
  end

  # A workflow is starting, record all of the information from its start event
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow)) }
  def initialize_workflow
  end

  # A workflow is starting, record all of the information from its start event
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow)).void }
  def initialize_workflow=(value)
  end

  # A workflow is starting, record all of the information from its start event
  sig { void }
  def clear_initialize_workflow
  end

  # A timer has fired, allowing whatever was waiting on it (if anything) to proceed
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer)) }
  def fire_timer
  end

  # A timer has fired, allowing whatever was waiting on it (if anything) to proceed
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer)).void }
  def fire_timer=(value)
  end

  # A timer has fired, allowing whatever was waiting on it (if anything) to proceed
  sig { void }
  def clear_fire_timer
  end

  # Workflow was reset. The randomness seed must be updated.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed)) }
  def update_random_seed
  end

  # Workflow was reset. The randomness seed must be updated.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed)).void }
  def update_random_seed=(value)
  end

  # Workflow was reset. The randomness seed must be updated.
  sig { void }
  def clear_update_random_seed
  end

  # A request to query the workflow was received. It is guaranteed that queries (one or more)
# always come in their own activation after other mutating jobs.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow)) }
  def query_workflow
  end

  # A request to query the workflow was received. It is guaranteed that queries (one or more)
# always come in their own activation after other mutating jobs.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow)).void }
  def query_workflow=(value)
  end

  # A request to query the workflow was received. It is guaranteed that queries (one or more)
# always come in their own activation after other mutating jobs.
  sig { void }
  def clear_query_workflow
  end

  # A request to cancel the workflow was received.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow)) }
  def cancel_workflow
  end

  # A request to cancel the workflow was received.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow)).void }
  def cancel_workflow=(value)
  end

  # A request to cancel the workflow was received.
  sig { void }
  def clear_cancel_workflow
  end

  # A request to signal the workflow was received.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow)) }
  def signal_workflow
  end

  # A request to signal the workflow was received.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow)).void }
  def signal_workflow=(value)
  end

  # A request to signal the workflow was received.
  sig { void }
  def clear_signal_workflow
  end

  # An activity was resolved, result could be completed, failed or cancelled
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity)) }
  def resolve_activity
  end

  # An activity was resolved, result could be completed, failed or cancelled
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity)).void }
  def resolve_activity=(value)
  end

  # An activity was resolved, result could be completed, failed or cancelled
  sig { void }
  def clear_resolve_activity
  end

  # A patch marker has been detected and lang is being told that change exists. This
# job is strange in that it is sent pre-emptively to lang without any corresponding
# command being sent first.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch)) }
  def notify_has_patch
  end

  # A patch marker has been detected and lang is being told that change exists. This
# job is strange in that it is sent pre-emptively to lang without any corresponding
# command being sent first.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch)).void }
  def notify_has_patch=(value)
  end

  # A patch marker has been detected and lang is being told that change exists. This
# job is strange in that it is sent pre-emptively to lang without any corresponding
# command being sent first.
  sig { void }
  def clear_notify_has_patch
  end

  # A child workflow execution has started or failed to start
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart)) }
  def resolve_child_workflow_execution_start
  end

  # A child workflow execution has started or failed to start
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart)).void }
  def resolve_child_workflow_execution_start=(value)
  end

  # A child workflow execution has started or failed to start
  sig { void }
  def clear_resolve_child_workflow_execution_start
  end

  # A child workflow was resolved, result could be completed or failed
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution)) }
  def resolve_child_workflow_execution
  end

  # A child workflow was resolved, result could be completed or failed
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution)).void }
  def resolve_child_workflow_execution=(value)
  end

  # A child workflow was resolved, result could be completed or failed
  sig { void }
  def clear_resolve_child_workflow_execution
  end

  # An attempt to signal an external workflow resolved
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow)) }
  def resolve_signal_external_workflow
  end

  # An attempt to signal an external workflow resolved
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow)).void }
  def resolve_signal_external_workflow=(value)
  end

  # An attempt to signal an external workflow resolved
  sig { void }
  def clear_resolve_signal_external_workflow
  end

  # An attempt to cancel an external workflow resolved
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow)) }
  def resolve_request_cancel_external_workflow
  end

  # An attempt to cancel an external workflow resolved
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow)).void }
  def resolve_request_cancel_external_workflow=(value)
  end

  # An attempt to cancel an external workflow resolved
  sig { void }
  def clear_resolve_request_cancel_external_workflow
  end

  # A request to handle a workflow update.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate)) }
  def do_update
  end

  # A request to handle a workflow update.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate)).void }
  def do_update=(value)
  end

  # A request to handle a workflow update.
  sig { void }
  def clear_do_update
  end

  # Remove the workflow identified by the [WorkflowActivation] containing this job from the
# cache after performing the activation. It is guaranteed that this will be the only job
# in the activation if present.
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache)) }
  def remove_from_cache
  end

  # Remove the workflow identified by the [WorkflowActivation] containing this job from the
# cache after performing the activation. It is guaranteed that this will be the only job
# in the activation if present.
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache)).void }
  def remove_from_cache=(value)
  end

  # Remove the workflow identified by the [WorkflowActivation] containing this job from the
# cache after performing the activation. It is guaranteed that this will be the only job
# in the activation if present.
  sig { void }
  def clear_remove_from_cache
  end

  sig { returns(T.nilable(Symbol)) }
  def variant
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Initialize a new workflow
class Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::InitializeWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_type: T.nilable(String),
      workflow_id: T.nilable(String),
      arguments: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      randomness_seed: T.nilable(Integer),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      identity: T.nilable(String),
      parent_workflow_info: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution),
      workflow_execution_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_run_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_task_timeout: T.nilable(Google::Protobuf::Duration),
      continued_from_execution_run_id: T.nilable(String),
      continued_initiator: T.nilable(T.any(Symbol, String, Integer)),
      continued_failure: T.nilable(Temporalio::Api::Failure::V1::Failure),
      last_completion_result: T.nilable(Temporalio::Api::Common::V1::Payloads),
      first_execution_run_id: T.nilable(String),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      attempt: T.nilable(Integer),
      cron_schedule: T.nilable(String),
      workflow_execution_expiration_time: T.nilable(Google::Protobuf::Timestamp),
      cron_schedule_to_schedule_interval: T.nilable(Google::Protobuf::Duration),
      memo: T.nilable(Temporalio::Api::Common::V1::Memo),
      search_attributes: T.nilable(Temporalio::Api::Common::V1::SearchAttributes),
      start_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    workflow_type: "",
    workflow_id: "",
    arguments: [],
    randomness_seed: 0,
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    identity: "",
    parent_workflow_info: nil,
    workflow_execution_timeout: nil,
    workflow_run_timeout: nil,
    workflow_task_timeout: nil,
    continued_from_execution_run_id: "",
    continued_initiator: :CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED,
    continued_failure: nil,
    last_completion_result: nil,
    first_execution_run_id: "",
    retry_policy: nil,
    attempt: 0,
    cron_schedule: "",
    workflow_execution_expiration_time: nil,
    cron_schedule_to_schedule_interval: nil,
    memo: nil,
    search_attributes: nil,
    start_time: nil
  )
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { returns(String) }
  def workflow_type
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { params(value: String).void }
  def workflow_type=(value)
  end

  # The identifier the lang-specific sdk uses to execute workflow code
  sig { void }
  def clear_workflow_type
  end

  # The workflow id used on the temporal server
  sig { returns(String) }
  def workflow_id
  end

  # The workflow id used on the temporal server
  sig { params(value: String).void }
  def workflow_id=(value)
  end

  # The workflow id used on the temporal server
  sig { void }
  def clear_workflow_id
  end

  # Inputs to the workflow code
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def arguments
  end

  # Inputs to the workflow code
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def arguments=(value)
  end

  # Inputs to the workflow code
  sig { void }
  def clear_arguments
  end

  # The seed must be used to initialize the random generator used by SDK.
# RandomSeedUpdatedAttributes are used to deliver seed updates.
  sig { returns(Integer) }
  def randomness_seed
  end

  # The seed must be used to initialize the random generator used by SDK.
# RandomSeedUpdatedAttributes are used to deliver seed updates.
  sig { params(value: Integer).void }
  def randomness_seed=(value)
  end

  # The seed must be used to initialize the random generator used by SDK.
# RandomSeedUpdatedAttributes are used to deliver seed updates.
  sig { void }
  def clear_randomness_seed
  end

  # Used to add metadata e.g. for tracing and auth, meant to be read and written to by interceptors.
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Used to add metadata e.g. for tracing and auth, meant to be read and written to by interceptors.
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Used to add metadata e.g. for tracing and auth, meant to be read and written to by interceptors.
  sig { void }
  def clear_headers
  end

  # Identity of the client who requested this execution
  sig { returns(String) }
  def identity
  end

  # Identity of the client who requested this execution
  sig { params(value: String).void }
  def identity=(value)
  end

  # Identity of the client who requested this execution
  sig { void }
  def clear_identity
  end

  # If this workflow is a child, information about the parent
  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)) }
  def parent_workflow_info
  end

  # If this workflow is a child, information about the parent
  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::Common::NamespacedWorkflowExecution)).void }
  def parent_workflow_info=(value)
  end

  # If this workflow is a child, information about the parent
  sig { void }
  def clear_parent_workflow_info
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_execution_timeout
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_execution_timeout=(value)
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { void }
  def clear_workflow_execution_timeout
  end

  # Timeout of a single workflow run.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_run_timeout
  end

  # Timeout of a single workflow run.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_run_timeout=(value)
  end

  # Timeout of a single workflow run.
  sig { void }
  def clear_workflow_run_timeout
  end

  # Timeout of a single workflow task.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_task_timeout
  end

  # Timeout of a single workflow task.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_task_timeout=(value)
  end

  # Timeout of a single workflow task.
  sig { void }
  def clear_workflow_task_timeout
  end

  # Run id of the previous workflow which continued-as-new or retired or cron executed into this
# workflow, if any.
  sig { returns(String) }
  def continued_from_execution_run_id
  end

  # Run id of the previous workflow which continued-as-new or retired or cron executed into this
# workflow, if any.
  sig { params(value: String).void }
  def continued_from_execution_run_id=(value)
  end

  # Run id of the previous workflow which continued-as-new or retired or cron executed into this
# workflow, if any.
  sig { void }
  def clear_continued_from_execution_run_id
  end

  # If this workflow was a continuation, indicates the type of continuation.
  sig { returns(T.any(Symbol, Integer)) }
  def continued_initiator
  end

  # If this workflow was a continuation, indicates the type of continuation.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def continued_initiator=(value)
  end

  # If this workflow was a continuation, indicates the type of continuation.
  sig { void }
  def clear_continued_initiator
  end

  # If this workflow was a continuation and that continuation failed, the details of that.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def continued_failure
  end

  # If this workflow was a continuation and that continuation failed, the details of that.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def continued_failure=(value)
  end

  # If this workflow was a continuation and that continuation failed, the details of that.
  sig { void }
  def clear_continued_failure
  end

  # If this workflow was a continuation and that continuation completed, the details of that.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payloads)) }
  def last_completion_result
  end

  # If this workflow was a continuation and that continuation completed, the details of that.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payloads)).void }
  def last_completion_result=(value)
  end

  # If this workflow was a continuation and that continuation completed, the details of that.
  sig { void }
  def clear_last_completion_result
  end

  # This is the very first run id the workflow ever had, following continuation chains.
  sig { returns(String) }
  def first_execution_run_id
  end

  # This is the very first run id the workflow ever had, following continuation chains.
  sig { params(value: String).void }
  def first_execution_run_id=(value)
  end

  # This is the very first run id the workflow ever had, following continuation chains.
  sig { void }
  def clear_first_execution_run_id
  end

  # This workflow's retry policy
  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  # This workflow's retry policy
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  # This workflow's retry policy
  sig { void }
  def clear_retry_policy
  end

  # Starting at 1, the number of times we have tried to execute this workflow
  sig { returns(Integer) }
  def attempt
  end

  # Starting at 1, the number of times we have tried to execute this workflow
  sig { params(value: Integer).void }
  def attempt=(value)
  end

  # Starting at 1, the number of times we have tried to execute this workflow
  sig { void }
  def clear_attempt
  end

  # If this workflow runs on a cron schedule, it will appear here
  sig { returns(String) }
  def cron_schedule
  end

  # If this workflow runs on a cron schedule, it will appear here
  sig { params(value: String).void }
  def cron_schedule=(value)
  end

  # If this workflow runs on a cron schedule, it will appear here
  sig { void }
  def clear_cron_schedule
  end

  # The absolute time at which the workflow will be timed out.
# This is passed without change to the next run/retry of a workflow.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def workflow_execution_expiration_time
  end

  # The absolute time at which the workflow will be timed out.
# This is passed without change to the next run/retry of a workflow.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def workflow_execution_expiration_time=(value)
  end

  # The absolute time at which the workflow will be timed out.
# This is passed without change to the next run/retry of a workflow.
  sig { void }
  def clear_workflow_execution_expiration_time
  end

  # For a cron workflow, this contains the amount of time between when this iteration of
# the cron workflow was scheduled and when it should run next per its cron_schedule.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def cron_schedule_to_schedule_interval
  end

  # For a cron workflow, this contains the amount of time between when this iteration of
# the cron workflow was scheduled and when it should run next per its cron_schedule.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def cron_schedule_to_schedule_interval=(value)
  end

  # For a cron workflow, this contains the amount of time between when this iteration of
# the cron workflow was scheduled and when it should run next per its cron_schedule.
  sig { void }
  def clear_cron_schedule_to_schedule_interval
  end

  # User-defined memo
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Memo)) }
  def memo
  end

  # User-defined memo
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Memo)).void }
  def memo=(value)
  end

  # User-defined memo
  sig { void }
  def clear_memo
  end

  # Search attributes created/updated when this workflow was started
  sig { returns(T.nilable(Temporalio::Api::Common::V1::SearchAttributes)) }
  def search_attributes
  end

  # Search attributes created/updated when this workflow was started
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::SearchAttributes)).void }
  def search_attributes=(value)
  end

  # Search attributes created/updated when this workflow was started
  sig { void }
  def clear_search_attributes
  end

  # When the workflow execution started event was first written
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def start_time
  end

  # When the workflow execution started event was first written
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def start_time=(value)
  end

  # When the workflow execution started event was first written
  sig { void }
  def clear_start_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Notify a workflow that a timer has fired
class Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::FireTimer, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer)
    ).void
  end
  def initialize(
    seq: 0
  )
  end

  # Sequence number as provided by lang in the corresponding StartTimer command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding StartTimer command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding StartTimer command
  sig { void }
  def clear_seq
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Notify a workflow that an activity has been resolved
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveActivity, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      result: T.nilable(Temporalio::Internal::Bridge::Api::ActivityResult::ActivityResolution),
      is_local: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    seq: 0,
    result: nil,
    is_local: false
  )
  end

  # Sequence number as provided by lang in the corresponding ScheduleActivity command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding ScheduleActivity command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding ScheduleActivity command
  sig { void }
  def clear_seq
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::ActivityResult::ActivityResolution)) }
  def result
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::ActivityResult::ActivityResolution)).void }
  def result=(value)
  end

  sig { void }
  def clear_result
  end

  # Set to true if the resolution is for a local activity. This is used internally by Core and
# lang does not need to care about it.
  sig { returns(T::Boolean) }
  def is_local
  end

  # Set to true if the resolution is for a local activity. This is used internally by Core and
# lang does not need to care about it.
  sig { params(value: T::Boolean).void }
  def is_local=(value)
  end

  # Set to true if the resolution is for a local activity. This is used internally by Core and
# lang does not need to care about it.
  sig { void }
  def clear_is_local
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Notify a workflow that a start child workflow execution request has succeeded, failed or was
# cancelled.
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStart, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      succeeded: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess),
      failed: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure),
      cancelled: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled)
    ).void
  end
  def initialize(
    seq: 0,
    succeeded: nil,
    failed: nil,
    cancelled: nil
  )
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { void }
  def clear_seq
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess)) }
  def succeeded
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess)).void }
  def succeeded=(value)
  end

  sig { void }
  def clear_succeeded
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure)) }
  def failed
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure)).void }
  def failed=(value)
  end

  sig { void }
  def clear_failed
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled)) }
  def cancelled
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled)).void }
  def cancelled=(value)
  end

  sig { void }
  def clear_cancelled
  end

  sig { returns(T.nilable(Symbol)) }
  def status
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Simply pass the run_id to lang
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartSuccess, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      run_id: T.nilable(String)
    ).void
  end
  def initialize(
    run_id: ""
  )
  end

  sig { returns(String) }
  def run_id
  end

  sig { params(value: String).void }
  def run_id=(value)
  end

  sig { void }
  def clear_run_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Provide lang the cause of failure
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartFailure, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_id: T.nilable(String),
      workflow_type: T.nilable(String),
      cause: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    workflow_id: "",
    workflow_type: "",
    cause: :START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED
  )
  end

  # Lang should have this information but it's more convenient to pass it back
# for error construction on the lang side.
  sig { returns(String) }
  def workflow_id
  end

  # Lang should have this information but it's more convenient to pass it back
# for error construction on the lang side.
  sig { params(value: String).void }
  def workflow_id=(value)
  end

  # Lang should have this information but it's more convenient to pass it back
# for error construction on the lang side.
  sig { void }
  def clear_workflow_id
  end

  sig { returns(String) }
  def workflow_type
  end

  sig { params(value: String).void }
  def workflow_type=(value)
  end

  sig { void }
  def clear_workflow_type
  end

  sig { returns(T.any(Symbol, Integer)) }
  def cause
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def cause=(value)
  end

  sig { void }
  def clear_cause
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# `failure` should be ChildWorkflowFailure with cause set to CancelledFailure.
# The failure is constructed in core for lang's convenience.
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecutionStartCancelled, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      failure: T.nilable(Temporalio::Api::Failure::V1::Failure)
    ).void
  end
  def initialize(
    failure: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def failure
  end

  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def failure=(value)
  end

  sig { void }
  def clear_failure
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Notify a workflow that a child workflow execution has been resolved
class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveChildWorkflowExecution, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      result: T.nilable(Temporalio::Internal::Bridge::Api::ChildWorkflow::ChildWorkflowResult)
    ).void
  end
  def initialize(
    seq: 0,
    result: nil
  )
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  sig { void }
  def clear_seq
  end

  sig { returns(T.nilable(Temporalio::Internal::Bridge::Api::ChildWorkflow::ChildWorkflowResult)) }
  def result
  end

  sig { params(value: T.nilable(Temporalio::Internal::Bridge::Api::ChildWorkflow::ChildWorkflowResult)).void }
  def result=(value)
  end

  sig { void }
  def clear_result
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Update the workflow's random seed
class Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::UpdateRandomSeed, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      randomness_seed: T.nilable(Integer)
    ).void
  end
  def initialize(
    randomness_seed: 0
  )
  end

  sig { returns(Integer) }
  def randomness_seed
  end

  sig { params(value: Integer).void }
  def randomness_seed=(value)
  end

  sig { void }
  def clear_randomness_seed
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Query a workflow
class Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::QueryWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      query_id: T.nilable(String),
      query_type: T.nilable(String),
      arguments: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)])
    ).void
  end
  def initialize(
    query_id: "",
    query_type: "",
    arguments: [],
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload)
  )
  end

  # For PollWFTResp `query` field, this will be set to the special value `legacy`. For the
# `queries` field, the server provides a unique identifier. If it is a `legacy` query,
# lang cannot issue any commands in response other than to answer the query.
  sig { returns(String) }
  def query_id
  end

  # For PollWFTResp `query` field, this will be set to the special value `legacy`. For the
# `queries` field, the server provides a unique identifier. If it is a `legacy` query,
# lang cannot issue any commands in response other than to answer the query.
  sig { params(value: String).void }
  def query_id=(value)
  end

  # For PollWFTResp `query` field, this will be set to the special value `legacy`. For the
# `queries` field, the server provides a unique identifier. If it is a `legacy` query,
# lang cannot issue any commands in response other than to answer the query.
  sig { void }
  def clear_query_id
  end

  # The query's function/method/etc name
  sig { returns(String) }
  def query_type
  end

  # The query's function/method/etc name
  sig { params(value: String).void }
  def query_type=(value)
  end

  # The query's function/method/etc name
  sig { void }
  def clear_query_type
  end

  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def arguments
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def arguments=(value)
  end

  sig { void }
  def clear_arguments
  end

  # Headers attached to the query
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Headers attached to the query
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Headers attached to the query
  sig { void }
  def clear_headers
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Cancel a running workflow
class Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::CancelWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      details: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)])
    ).void
  end
  def initialize(
    details: []
  )
  end

  # Information from the cancellation request
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def details
  end

  # Information from the cancellation request
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def details=(value)
  end

  # Information from the cancellation request
  sig { void }
  def clear_details
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Send a signal to a workflow
class Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::SignalWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      signal_name: T.nilable(String),
      input: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      identity: T.nilable(String),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)])
    ).void
  end
  def initialize(
    signal_name: "",
    input: [],
    identity: "",
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload)
  )
  end

  sig { returns(String) }
  def signal_name
  end

  sig { params(value: String).void }
  def signal_name=(value)
  end

  sig { void }
  def clear_signal_name
  end

  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def input
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def input=(value)
  end

  sig { void }
  def clear_input
  end

  # Identity of the sender of the signal
  sig { returns(String) }
  def identity
  end

  # Identity of the sender of the signal
  sig { params(value: String).void }
  def identity=(value)
  end

  # Identity of the sender of the signal
  sig { void }
  def clear_identity
  end

  # Headers attached to the signal
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Headers attached to the signal
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Headers attached to the signal
  sig { void }
  def clear_headers
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Inform lang what the result of a call to `patched` or similar API should be -- this is always
# sent pre-emptively, so any time it is sent the change is present
class Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::NotifyHasPatch, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      patch_id: T.nilable(String)
    ).void
  end
  def initialize(
    patch_id: ""
  )
  end

  sig { returns(String) }
  def patch_id
  end

  sig { params(value: String).void }
  def patch_id=(value)
  end

  sig { void }
  def clear_patch_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveSignalExternalWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      failure: T.nilable(Temporalio::Api::Failure::V1::Failure)
    ).void
  end
  def initialize(
    seq: 0,
    failure: nil
  )
  end

  # Sequence number as provided by lang in the corresponding SignalExternalWorkflowExecution
# command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding SignalExternalWorkflowExecution
# command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding SignalExternalWorkflowExecution
# command
  sig { void }
  def clear_seq
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def failure
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def failure=(value)
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { void }
  def clear_failure
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::ResolveRequestCancelExternalWorkflow, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      seq: T.nilable(Integer),
      failure: T.nilable(Temporalio::Api::Failure::V1::Failure)
    ).void
  end
  def initialize(
    seq: 0,
    failure: nil
  )
  end

  # Sequence number as provided by lang in the corresponding
# RequestCancelExternalWorkflowExecution command
  sig { returns(Integer) }
  def seq
  end

  # Sequence number as provided by lang in the corresponding
# RequestCancelExternalWorkflowExecution command
  sig { params(value: Integer).void }
  def seq=(value)
  end

  # Sequence number as provided by lang in the corresponding
# RequestCancelExternalWorkflowExecution command
  sig { void }
  def clear_seq
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def failure
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def failure=(value)
  end

  # If populated, this signal either failed to be sent or was cancelled depending on failure
# type / info.
  sig { void }
  def clear_failure
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Lang is requested to invoke an update handler on the workflow. Lang should invoke the update
# validator first (if requested). If it accepts the update, immediately invoke the update handler.
# Lang must reply to the activation containing this job with an `UpdateResponse`.
class Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::DoUpdate, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      id: T.nilable(String),
      protocol_instance_id: T.nilable(String),
      name: T.nilable(String),
      input: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]),
      headers: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]),
      meta: T.nilable(Temporalio::Api::Update::V1::Meta),
      run_validator: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    id: "",
    protocol_instance_id: "",
    name: "",
    input: [],
    headers: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Common::V1::Payload),
    meta: nil,
    run_validator: false
  )
  end

  # A workflow-unique identifier for this update
  sig { returns(String) }
  def id
  end

  # A workflow-unique identifier for this update
  sig { params(value: String).void }
  def id=(value)
  end

  # A workflow-unique identifier for this update
  sig { void }
  def clear_id
  end

  # The protocol message instance ID - this is used to uniquely track the ID server side and
# internally.
  sig { returns(String) }
  def protocol_instance_id
  end

  # The protocol message instance ID - this is used to uniquely track the ID server side and
# internally.
  sig { params(value: String).void }
  def protocol_instance_id=(value)
  end

  # The protocol message instance ID - this is used to uniquely track the ID server side and
# internally.
  sig { void }
  def clear_protocol_instance_id
  end

  # The name of the update handler
  sig { returns(String) }
  def name
  end

  # The name of the update handler
  sig { params(value: String).void }
  def name=(value)
  end

  # The name of the update handler
  sig { void }
  def clear_name
  end

  # The input to the update
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def input
  end

  # The input to the update
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def input=(value)
  end

  # The input to the update
  sig { void }
  def clear_input
  end

  # Headers attached to the update
  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Common::V1::Payload)]) }
  def headers
  end

  # Headers attached to the update
  sig { params(value: ::Google::Protobuf::Map).void }
  def headers=(value)
  end

  # Headers attached to the update
  sig { void }
  def clear_headers
  end

  # Remaining metadata associated with the update. The `update_id` field is stripped from here
# and moved to `id`, since it is guaranteed to be present.
  sig { returns(T.nilable(Temporalio::Api::Update::V1::Meta)) }
  def meta
  end

  # Remaining metadata associated with the update. The `update_id` field is stripped from here
# and moved to `id`, since it is guaranteed to be present.
  sig { params(value: T.nilable(Temporalio::Api::Update::V1::Meta)).void }
  def meta=(value)
  end

  # Remaining metadata associated with the update. The `update_id` field is stripped from here
# and moved to `id`, since it is guaranteed to be present.
  sig { void }
  def clear_meta
  end

  # If set true, lang must run the update's validator before running the handler. This will be
# set false during replay, since validation is not re-run during replay.
  sig { returns(T::Boolean) }
  def run_validator
  end

  # If set true, lang must run the update's validator before running the handler. This will be
# set false during replay, since validation is not re-run during replay.
  sig { params(value: T::Boolean).void }
  def run_validator=(value)
  end

  # If set true, lang must run the update's validator before running the handler. This will be
# set false during replay, since validation is not re-run during replay.
  sig { void }
  def clear_run_validator
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      message: T.nilable(String),
      reason: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    message: "",
    reason: :UNSPECIFIED
  )
  end

  sig { returns(String) }
  def message
  end

  sig { params(value: String).void }
  def message=(value)
  end

  sig { void }
  def clear_message
  end

  sig { returns(T.any(Symbol, Integer)) }
  def reason
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def reason=(value)
  end

  sig { void }
  def clear_reason
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

module Temporalio::Internal::Bridge::Api::WorkflowActivation::RemoveFromCache::EvictionReason
  self::UNSPECIFIED = T.let(0, Integer)
  self::CACHE_FULL = T.let(1, Integer)
  self::CACHE_MISS = T.let(2, Integer)
  self::NONDETERMINISM = T.let(3, Integer)
  self::LANG_FAIL = T.let(4, Integer)
  self::LANG_REQUESTED = T.let(5, Integer)
  self::TASK_NOT_FOUND = T.let(6, Integer)
  self::UNHANDLED_COMMAND = T.let(7, Integer)
  self::FATAL = T.let(8, Integer)
  self::PAGINATION_OR_HISTORY_FETCH = T.let(9, Integer)

  sig { params(value: Integer).returns(T.nilable(Symbol)) }
  def self.lookup(value)
  end

  sig { params(value: Symbol).returns(T.nilable(Integer)) }
  def self.resolve(value)
  end

  sig { returns(::Google::Protobuf::EnumDescriptor) }
  def self.descriptor
  end
end
