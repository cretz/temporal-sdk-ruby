# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/api/taskqueue/v1/message.proto
# typed: strict

# See https://docs.temporal.io/docs/concepts/task-queues/
class Temporalio::Api::TaskQueue::V1::TaskQueue
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueue) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueue).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueue) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueue, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      name: T.nilable(String),
      kind: T.nilable(T.any(Symbol, String, Integer)),
      normal_name: T.nilable(String)
    ).void
  end
  def initialize(
    name: "",
    kind: :TASK_QUEUE_KIND_UNSPECIFIED,
    normal_name: ""
  )
  end

  sig { returns(String) }
  def name
  end

  sig { params(value: String).void }
  def name=(value)
  end

  sig { void }
  def clear_name
  end

  # Default: TASK_QUEUE_KIND_NORMAL.
  sig { returns(T.any(Symbol, Integer)) }
  def kind
  end

  # Default: TASK_QUEUE_KIND_NORMAL.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def kind=(value)
  end

  # Default: TASK_QUEUE_KIND_NORMAL.
  sig { void }
  def clear_kind
  end

  # Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
# the normal task queue that the sticky worker is running on.
  sig { returns(String) }
  def normal_name
  end

  # Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
# the normal task queue that the sticky worker is running on.
  sig { params(value: String).void }
  def normal_name=(value)
  end

  # Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
# the normal task queue that the sticky worker is running on.
  sig { void }
  def clear_normal_name
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Only applies to activity task queues
class Temporalio::Api::TaskQueue::V1::TaskQueueMetadata
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueMetadata) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueMetadata).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueMetadata) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueMetadata, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      max_tasks_per_second: T.nilable(Google::Protobuf::DoubleValue)
    ).void
  end
  def initialize(
    max_tasks_per_second: nil
  )
  end

  # Allows throttling dispatch of tasks from this queue
  sig { returns(T.nilable(Google::Protobuf::DoubleValue)) }
  def max_tasks_per_second
  end

  # Allows throttling dispatch of tasks from this queue
  sig { params(value: T.nilable(Google::Protobuf::DoubleValue)).void }
  def max_tasks_per_second=(value)
  end

  # Allows throttling dispatch of tasks from this queue
  sig { void }
  def clear_max_tasks_per_second
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Used for specifying versions the caller is interested in.
class Temporalio::Api::TaskQueue::V1::TaskQueueVersionSelection
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueVersionSelection) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueVersionSelection).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueVersionSelection) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueVersionSelection, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      build_ids: T.nilable(T::Array[String]),
      unversioned: T.nilable(T::Boolean),
      all_active: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    build_ids: [],
    unversioned: false,
    all_active: false
  )
  end

  # Include specific Build IDs.
  sig { returns(T::Array[String]) }
  def build_ids
  end

  # Include specific Build IDs.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def build_ids=(value)
  end

  # Include specific Build IDs.
  sig { void }
  def clear_build_ids
  end

  # Include the unversioned queue.
  sig { returns(T::Boolean) }
  def unversioned
  end

  # Include the unversioned queue.
  sig { params(value: T::Boolean).void }
  def unversioned=(value)
  end

  # Include the unversioned queue.
  sig { void }
  def clear_unversioned
  end

  # Include all active versions. A version is considered active if it has had new
# tasks or polls recently.
  sig { returns(T::Boolean) }
  def all_active
  end

  # Include all active versions. A version is considered active if it has had new
# tasks or polls recently.
  sig { params(value: T::Boolean).void }
  def all_active=(value)
  end

  # Include all active versions. A version is considered active if it has had new
# tasks or polls recently.
  sig { void }
  def clear_all_active
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TaskQueueVersionInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueVersionInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueVersionInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueVersionInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueVersionInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      types_info: T.nilable(T::Hash[Integer, T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo)]),
      task_reachability: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    types_info: ::Google::Protobuf::Map.new(:int32, :message, Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo),
    task_reachability: :BUILD_ID_TASK_REACHABILITY_UNSPECIFIED
  )
  end

  # Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
  sig { returns(T::Hash[Integer, T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo)]) }
  def types_info
  end

  # Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
  sig { params(value: ::Google::Protobuf::Map).void }
  def types_info=(value)
  end

  # Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
  sig { void }
  def clear_types_info
  end

  # Task Reachability is eventually consistent; there may be a delay until it converges to the most
# accurate value but it is designed in a way to take the more conservative side until it converges.
# For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
#
# Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
# accounted for reachability as server cannot know if they'll happen as they do not use
# assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
# who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
# sure to query reachability for the parent/previous workflow's Task Queue as well.
  sig { returns(T.any(Symbol, Integer)) }
  def task_reachability
  end

  # Task Reachability is eventually consistent; there may be a delay until it converges to the most
# accurate value but it is designed in a way to take the more conservative side until it converges.
# For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
#
# Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
# accounted for reachability as server cannot know if they'll happen as they do not use
# assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
# who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
# sure to query reachability for the parent/previous workflow's Task Queue as well.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def task_reachability=(value)
  end

  # Task Reachability is eventually consistent; there may be a delay until it converges to the most
# accurate value but it is designed in a way to take the more conservative side until it converges.
# For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
#
# Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
# accounted for reachability as server cannot know if they'll happen as they do not use
# assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
# who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
# sure to query reachability for the parent/previous workflow's Task Queue as well.
  sig { void }
  def clear_task_reachability
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueTypeInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      pollers: T.nilable(T::Array[T.nilable(Temporalio::Api::TaskQueue::V1::PollerInfo)]),
      stats: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueStats)
    ).void
  end
  def initialize(
    pollers: [],
    stats: nil
  )
  end

  # Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
  sig { returns(T::Array[T.nilable(Temporalio::Api::TaskQueue::V1::PollerInfo)]) }
  def pollers
  end

  # Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def pollers=(value)
  end

  # Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
  sig { void }
  def clear_pollers
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueStats)) }
  def stats
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueStats)).void }
  def stats=(value)
  end

  sig { void }
  def clear_stats
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# For workflow task queues, we only report the normal queue stats, not sticky queues. This means the stats
# reported here do not count all workflow tasks. However, because the tasks queued in sticky queues only remain
# valid for a few seconds, the inaccuracy becomes less significant as the backlog age grows.
class Temporalio::Api::TaskQueue::V1::TaskQueueStats
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueStats) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueStats).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueStats) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueStats, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      approximate_backlog_count: T.nilable(Integer),
      approximate_backlog_age: T.nilable(Google::Protobuf::Duration),
      tasks_add_rate: T.nilable(Float),
      tasks_dispatch_rate: T.nilable(Float)
    ).void
  end
  def initialize(
    approximate_backlog_count: 0,
    approximate_backlog_age: nil,
    tasks_add_rate: 0.0,
    tasks_dispatch_rate: 0.0
  )
  end

  # The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually converges
# to the right value.
  sig { returns(Integer) }
  def approximate_backlog_count
  end

  # The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually converges
# to the right value.
  sig { params(value: Integer).void }
  def approximate_backlog_count=(value)
  end

  # The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually converges
# to the right value.
  sig { void }
  def clear_approximate_backlog_count
  end

  # Approximate age of the oldest task in the backlog based on the create timestamp of the task at the head of the queue.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def approximate_backlog_age
  end

  # Approximate age of the oldest task in the backlog based on the create timestamp of the task at the head of the queue.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def approximate_backlog_age=(value)
  end

  # Approximate age of the oldest task in the backlog based on the create timestamp of the task at the head of the queue.
  sig { void }
  def clear_approximate_backlog_age
  end

  # Approximate tasks per second added to the task queue based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { returns(Float) }
  def tasks_add_rate
  end

  # Approximate tasks per second added to the task queue based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { params(value: Float).void }
  def tasks_add_rate=(value)
  end

  # Approximate tasks per second added to the task queue based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { void }
  def clear_tasks_add_rate
  end

  # Approximate tasks per second dispatched to workers based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { returns(Float) }
  def tasks_dispatch_rate
  end

  # Approximate tasks per second dispatched to workers based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { params(value: Float).void }
  def tasks_dispatch_rate=(value)
  end

  # Approximate tasks per second dispatched to workers based on activity within a fixed window. This includes both backlogged and
# sync-matched tasks.
  sig { void }
  def clear_tasks_dispatch_rate
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
class Temporalio::Api::TaskQueue::V1::TaskQueueStatus
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueStatus) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueStatus).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueStatus) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueStatus, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      backlog_count_hint: T.nilable(Integer),
      read_level: T.nilable(Integer),
      ack_level: T.nilable(Integer),
      rate_per_second: T.nilable(Float),
      task_id_block: T.nilable(Temporalio::Api::TaskQueue::V1::TaskIdBlock)
    ).void
  end
  def initialize(
    backlog_count_hint: 0,
    read_level: 0,
    ack_level: 0,
    rate_per_second: 0.0,
    task_id_block: nil
  )
  end

  sig { returns(Integer) }
  def backlog_count_hint
  end

  sig { params(value: Integer).void }
  def backlog_count_hint=(value)
  end

  sig { void }
  def clear_backlog_count_hint
  end

  sig { returns(Integer) }
  def read_level
  end

  sig { params(value: Integer).void }
  def read_level=(value)
  end

  sig { void }
  def clear_read_level
  end

  sig { returns(Integer) }
  def ack_level
  end

  sig { params(value: Integer).void }
  def ack_level=(value)
  end

  sig { void }
  def clear_ack_level
  end

  sig { returns(Float) }
  def rate_per_second
  end

  sig { params(value: Float).void }
  def rate_per_second=(value)
  end

  sig { void }
  def clear_rate_per_second
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::TaskIdBlock)) }
  def task_id_block
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::TaskIdBlock)).void }
  def task_id_block=(value)
  end

  sig { void }
  def clear_task_id_block
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TaskIdBlock
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskIdBlock) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskIdBlock).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskIdBlock) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskIdBlock, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      start_id: T.nilable(Integer),
      end_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    start_id: 0,
    end_id: 0
  )
  end

  sig { returns(Integer) }
  def start_id
  end

  sig { params(value: Integer).void }
  def start_id=(value)
  end

  sig { void }
  def clear_start_id
  end

  sig { returns(Integer) }
  def end_id
  end

  sig { params(value: Integer).void }
  def end_id=(value)
  end

  sig { void }
  def clear_end_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TaskQueuePartitionMetadata
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueuePartitionMetadata) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueuePartitionMetadata).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueuePartitionMetadata) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueuePartitionMetadata, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      key: T.nilable(String),
      owner_host_name: T.nilable(String)
    ).void
  end
  def initialize(
    key: "",
    owner_host_name: ""
  )
  end

  sig { returns(String) }
  def key
  end

  sig { params(value: String).void }
  def key=(value)
  end

  sig { void }
  def clear_key
  end

  sig { returns(String) }
  def owner_host_name
  end

  sig { params(value: String).void }
  def owner_host_name=(value)
  end

  sig { void }
  def clear_owner_host_name
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::PollerInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::PollerInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::PollerInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::PollerInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::PollerInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      last_access_time: T.nilable(Google::Protobuf::Timestamp),
      identity: T.nilable(String),
      rate_per_second: T.nilable(Float),
      worker_version_capabilities: T.nilable(Temporalio::Api::Common::V1::WorkerVersionCapabilities)
    ).void
  end
  def initialize(
    last_access_time: nil,
    identity: "",
    rate_per_second: 0.0,
    worker_version_capabilities: nil
  )
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_access_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_access_time=(value)
  end

  sig { void }
  def clear_last_access_time
  end

  sig { returns(String) }
  def identity
  end

  sig { params(value: String).void }
  def identity=(value)
  end

  sig { void }
  def clear_identity
  end

  sig { returns(Float) }
  def rate_per_second
  end

  sig { params(value: Float).void }
  def rate_per_second=(value)
  end

  sig { void }
  def clear_rate_per_second
  end

  # If a worker has opted into the worker versioning feature while polling, its capabilities will
# appear here.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkerVersionCapabilities)) }
  def worker_version_capabilities
  end

  # If a worker has opted into the worker versioning feature while polling, its capabilities will
# appear here.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkerVersionCapabilities)).void }
  def worker_version_capabilities=(value)
  end

  # If a worker has opted into the worker versioning feature while polling, its capabilities will
# appear here.
  sig { void }
  def clear_worker_version_capabilities
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::StickyExecutionAttributes
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::StickyExecutionAttributes) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::StickyExecutionAttributes).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::StickyExecutionAttributes) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::StickyExecutionAttributes, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      worker_task_queue: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue),
      schedule_to_start_timeout: T.nilable(Google::Protobuf::Duration)
    ).void
  end
  def initialize(
    worker_task_queue: nil,
    schedule_to_start_timeout: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)) }
  def worker_task_queue
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)).void }
  def worker_task_queue=(value)
  end

  sig { void }
  def clear_worker_task_queue
  end

  # (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_start_timeout
  end

  # (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_start_timeout=(value)
  end

  # (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { void }
  def clear_schedule_to_start_timeout
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Used by the worker versioning APIs, represents an unordered set of one or more versions which are
# considered to be compatible with each other. Currently the versions are always worker build IDs.
class Temporalio::Api::TaskQueue::V1::CompatibleVersionSet
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::CompatibleVersionSet) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::CompatibleVersionSet).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::CompatibleVersionSet) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::CompatibleVersionSet, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      build_ids: T.nilable(T::Array[String])
    ).void
  end
  def initialize(
    build_ids: []
  )
  end

  # All the compatible versions, unordered, except for the last element, which is considered the set "default".
  sig { returns(T::Array[String]) }
  def build_ids
  end

  # All the compatible versions, unordered, except for the last element, which is considered the set "default".
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def build_ids=(value)
  end

  # All the compatible versions, unordered, except for the last element, which is considered the set "default".
  sig { void }
  def clear_build_ids
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Reachability of tasks for a worker on a single task queue.
class Temporalio::Api::TaskQueue::V1::TaskQueueReachability
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TaskQueueReachability) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueReachability).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TaskQueueReachability) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TaskQueueReachability, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      task_queue: T.nilable(String),
      reachability: T.nilable(T::Array[T.any(Symbol, String, Integer)])
    ).void
  end
  def initialize(
    task_queue: "",
    reachability: []
  )
  end

  sig { returns(String) }
  def task_queue
  end

  sig { params(value: String).void }
  def task_queue=(value)
  end

  sig { void }
  def clear_task_queue
  end

  # Task reachability for a worker in a single task queue.
# See the TaskReachability docstring for information about each enum variant.
# If reachability is empty, this worker is considered unreachable in this task queue.
  sig { returns(T::Array[T.any(Symbol, Integer)]) }
  def reachability
  end

  # Task reachability for a worker in a single task queue.
# See the TaskReachability docstring for information about each enum variant.
# If reachability is empty, this worker is considered unreachable in this task queue.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def reachability=(value)
  end

  # Task reachability for a worker in a single task queue.
# See the TaskReachability docstring for information about each enum variant.
# If reachability is empty, this worker is considered unreachable in this task queue.
  sig { void }
  def clear_reachability
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Reachability of tasks for a worker by build id, in one or more task queues.
class Temporalio::Api::TaskQueue::V1::BuildIdReachability
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::BuildIdReachability) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::BuildIdReachability).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::BuildIdReachability) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::BuildIdReachability, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      build_id: T.nilable(String),
      task_queue_reachability: T.nilable(T::Array[T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueReachability)])
    ).void
  end
  def initialize(
    build_id: "",
    task_queue_reachability: []
  )
  end

  # A build id or empty if unversioned.
  sig { returns(String) }
  def build_id
  end

  # A build id or empty if unversioned.
  sig { params(value: String).void }
  def build_id=(value)
  end

  # A build id or empty if unversioned.
  sig { void }
  def clear_build_id
  end

  # Reachability per task queue.
  sig { returns(T::Array[T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueueReachability)]) }
  def task_queue_reachability
  end

  # Reachability per task queue.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def task_queue_reachability=(value)
  end

  # Reachability per task queue.
  sig { void }
  def clear_task_queue_reachability
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::RampByPercentage
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::RampByPercentage) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::RampByPercentage).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::RampByPercentage) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::RampByPercentage, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      ramp_percentage: T.nilable(Float)
    ).void
  end
  def initialize(
    ramp_percentage: 0.0
  )
  end

  # Acceptable range is [0,100).
  sig { returns(Float) }
  def ramp_percentage
  end

  # Acceptable range is [0,100).
  sig { params(value: Float).void }
  def ramp_percentage=(value)
  end

  # Acceptable range is [0,100).
  sig { void }
  def clear_ramp_percentage
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Assignment rules are applied to *new* Workflow and Activity executions at
# schedule time to assign them to a Build ID.
#
# Assignment rules will not be used in the following cases:
#    - Child Workflows or Continue-As-New Executions who inherit their
#      parent/previous Workflow's assigned Build ID (by setting the
#      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
#      is used.)
#    - An Activity that inherits the assigned Build ID of its Workflow (by
#      setting the `use_workflow_build_id` flag - default behavior in SDKs
#      when the same Task Queue is used.)
#
# In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
# the task will be dispatched to Workers of the Build ID determined by the
# assignment rules (or inherited). Otherwise, the final Build ID will be
# determined by the redirect rules.
#
# Once a Workflow completes its first Workflow Task in a particular Build ID it
# stays in that Build ID regardless of changes to assignment rules. Redirect
# rules can be used to move the workflow to another compatible Build ID.
#
# When using Worker Versioning on a Task Queue, in the steady state,
# there should typically be a single assignment rule to send all new executions
# to the latest Build ID. Existence of at least one such "unconditional"
# rule at all times is enforces by the system, unless the `force` flag is used
# by the user when replacing/deleting these rules (for exceptional cases).
#
# During a deployment, one or more additional rules can be added to assign a
# subset of the tasks to a new Build ID based on a "ramp percentage".
#
# When there are multiple assignment rules for a Task Queue, the rules are
# evaluated in order, starting from index 0. The first applicable rule will be
# applied and the rest will be ignored.
#
# In the event that no assignment rule is applicable on a task (or the Task
# Queue is simply not versioned), the tasks will be dispatched to an
# unversioned Worker.
class Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      target_build_id: T.nilable(String),
      percentage_ramp: T.nilable(Temporalio::Api::TaskQueue::V1::RampByPercentage)
    ).void
  end
  def initialize(
    target_build_id: "",
    percentage_ramp: nil
  )
  end

  sig { returns(String) }
  def target_build_id
  end

  sig { params(value: String).void }
  def target_build_id=(value)
  end

  sig { void }
  def clear_target_build_id
  end

  # This ramp is useful for gradual Blue/Green deployments (and similar)
# where you want to send a certain portion of the traffic to the target
# Build ID.
  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::RampByPercentage)) }
  def percentage_ramp
  end

  # This ramp is useful for gradual Blue/Green deployments (and similar)
# where you want to send a certain portion of the traffic to the target
# Build ID.
  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::RampByPercentage)).void }
  def percentage_ramp=(value)
  end

  # This ramp is useful for gradual Blue/Green deployments (and similar)
# where you want to send a certain portion of the traffic to the target
# Build ID.
  sig { void }
  def clear_percentage_ramp
  end

  sig { returns(T.nilable(Symbol)) }
  def ramp
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# These rules apply to tasks assigned to a particular Build ID
# (`source_build_id`) to redirect them to another *compatible* Build ID
# (`target_build_id`).
#
# It is user's responsibility to ensure that the target Build ID is compatible
# with the source Build ID (e.g. by using the Patching API).
#
# Most deployments are not expected to need these rules, however following
# situations can greatly benefit from redirects:
#  - Need to move long-running Workflow Executions from an old Build ID to a
#    newer one.
#  - Need to hotfix some broken or stuck Workflow Executions.
#
# In steady state, redirect rules are beneficial when dealing with old
# Executions ran on now-decommissioned Build IDs:
#  - To redirecting the Workflow Queries to the current (compatible) Build ID.
#  - To be able to Reset an old Execution so it can run on the current
#    (compatible) Build ID.
#
# Redirect rules can be chained.
class Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      source_build_id: T.nilable(String),
      target_build_id: T.nilable(String)
    ).void
  end
  def initialize(
    source_build_id: "",
    target_build_id: ""
  )
  end

  sig { returns(String) }
  def source_build_id
  end

  sig { params(value: String).void }
  def source_build_id=(value)
  end

  sig { void }
  def clear_source_build_id
  end

  # Target Build ID must be compatible with the Source Build ID; that is it
# must be able to process event histories made by the Source Build ID by
# using [Patching](https://docs.temporal.io/workflows#patching) or other
# means.
  sig { returns(String) }
  def target_build_id
  end

  # Target Build ID must be compatible with the Source Build ID; that is it
# must be able to process event histories made by the Source Build ID by
# using [Patching](https://docs.temporal.io/workflows#patching) or other
# means.
  sig { params(value: String).void }
  def target_build_id=(value)
  end

  # Target Build ID must be compatible with the Source Build ID; that is it
# must be able to process event histories made by the Source Build ID by
# using [Patching](https://docs.temporal.io/workflows#patching) or other
# means.
  sig { void }
  def clear_target_build_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TimestampedBuildIdAssignmentRule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TimestampedBuildIdAssignmentRule) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TimestampedBuildIdAssignmentRule).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TimestampedBuildIdAssignmentRule) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TimestampedBuildIdAssignmentRule, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      rule: T.nilable(Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule),
      create_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    rule: nil,
    create_time: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule)) }
  def rule
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::BuildIdAssignmentRule)).void }
  def rule=(value)
  end

  sig { void }
  def clear_rule
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def create_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def create_time=(value)
  end

  sig { void }
  def clear_create_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::TaskQueue::V1::TimestampedCompatibleBuildIdRedirectRule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::TaskQueue::V1::TimestampedCompatibleBuildIdRedirectRule) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TimestampedCompatibleBuildIdRedirectRule).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::TaskQueue::V1::TimestampedCompatibleBuildIdRedirectRule) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::TaskQueue::V1::TimestampedCompatibleBuildIdRedirectRule, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      rule: T.nilable(Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule),
      create_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    rule: nil,
    create_time: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule)) }
  def rule
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::CompatibleBuildIdRedirectRule)).void }
  def rule=(value)
  end

  sig { void }
  def clear_rule
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def create_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def create_time=(value)
  end

  sig { void }
  def clear_create_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end
