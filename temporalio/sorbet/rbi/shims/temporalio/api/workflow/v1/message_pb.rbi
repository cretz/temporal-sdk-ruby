# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/api/workflow/v1/message.proto
# typed: strict

class Temporalio::Api::Workflow::V1::WorkflowExecutionInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::WorkflowExecutionInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::WorkflowExecutionInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::WorkflowExecutionInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::WorkflowExecutionInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      execution: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution),
      type: T.nilable(Temporalio::Api::Common::V1::WorkflowType),
      start_time: T.nilable(Google::Protobuf::Timestamp),
      close_time: T.nilable(Google::Protobuf::Timestamp),
      status: T.nilable(T.any(Symbol, String, Integer)),
      history_length: T.nilable(Integer),
      parent_namespace_id: T.nilable(String),
      parent_execution: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution),
      execution_time: T.nilable(Google::Protobuf::Timestamp),
      memo: T.nilable(Temporalio::Api::Common::V1::Memo),
      search_attributes: T.nilable(Temporalio::Api::Common::V1::SearchAttributes),
      auto_reset_points: T.nilable(Temporalio::Api::Workflow::V1::ResetPoints),
      task_queue: T.nilable(String),
      state_transition_count: T.nilable(Integer),
      history_size_bytes: T.nilable(Integer),
      most_recent_worker_version_stamp: T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp),
      execution_duration: T.nilable(Google::Protobuf::Duration),
      root_execution: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution),
      assigned_build_id: T.nilable(String),
      inherited_build_id: T.nilable(String)
    ).void
  end
  def initialize(
    execution: nil,
    type: nil,
    start_time: nil,
    close_time: nil,
    status: :WORKFLOW_EXECUTION_STATUS_UNSPECIFIED,
    history_length: 0,
    parent_namespace_id: "",
    parent_execution: nil,
    execution_time: nil,
    memo: nil,
    search_attributes: nil,
    auto_reset_points: nil,
    task_queue: "",
    state_transition_count: 0,
    history_size_bytes: 0,
    most_recent_worker_version_stamp: nil,
    execution_duration: nil,
    root_execution: nil,
    assigned_build_id: "",
    inherited_build_id: ""
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)) }
  def execution
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)).void }
  def execution=(value)
  end

  sig { void }
  def clear_execution
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowType)) }
  def type
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowType)).void }
  def type=(value)
  end

  sig { void }
  def clear_type
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def start_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def start_time=(value)
  end

  sig { void }
  def clear_start_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def close_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def close_time=(value)
  end

  sig { void }
  def clear_close_time
  end

  sig { returns(T.any(Symbol, Integer)) }
  def status
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def status=(value)
  end

  sig { void }
  def clear_status
  end

  sig { returns(Integer) }
  def history_length
  end

  sig { params(value: Integer).void }
  def history_length=(value)
  end

  sig { void }
  def clear_history_length
  end

  sig { returns(String) }
  def parent_namespace_id
  end

  sig { params(value: String).void }
  def parent_namespace_id=(value)
  end

  sig { void }
  def clear_parent_namespace_id
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)) }
  def parent_execution
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)).void }
  def parent_execution=(value)
  end

  sig { void }
  def clear_parent_execution
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def execution_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def execution_time=(value)
  end

  sig { void }
  def clear_execution_time
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Memo)) }
  def memo
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Memo)).void }
  def memo=(value)
  end

  sig { void }
  def clear_memo
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::SearchAttributes)) }
  def search_attributes
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::SearchAttributes)).void }
  def search_attributes=(value)
  end

  sig { void }
  def clear_search_attributes
  end

  sig { returns(T.nilable(Temporalio::Api::Workflow::V1::ResetPoints)) }
  def auto_reset_points
  end

  sig { params(value: T.nilable(Temporalio::Api::Workflow::V1::ResetPoints)).void }
  def auto_reset_points=(value)
  end

  sig { void }
  def clear_auto_reset_points
  end

  sig { returns(String) }
  def task_queue
  end

  sig { params(value: String).void }
  def task_queue=(value)
  end

  sig { void }
  def clear_task_queue
  end

  sig { returns(Integer) }
  def state_transition_count
  end

  sig { params(value: Integer).void }
  def state_transition_count=(value)
  end

  sig { void }
  def clear_state_transition_count
  end

  sig { returns(Integer) }
  def history_size_bytes
  end

  sig { params(value: Integer).void }
  def history_size_bytes=(value)
  end

  sig { void }
  def clear_history_size_bytes
  end

  # If set, the most recent worker version stamp that appeared in a workflow task completion
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp)) }
  def most_recent_worker_version_stamp
  end

  # If set, the most recent worker version stamp that appeared in a workflow task completion
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp)).void }
  def most_recent_worker_version_stamp=(value)
  end

  # If set, the most recent worker version stamp that appeared in a workflow task completion
  sig { void }
  def clear_most_recent_worker_version_stamp
  end

  # Workflow execution duration is defined as difference between close time and execution time.
# This field is only populated if the workflow is closed.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def execution_duration
  end

  # Workflow execution duration is defined as difference between close time and execution time.
# This field is only populated if the workflow is closed.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def execution_duration=(value)
  end

  # Workflow execution duration is defined as difference between close time and execution time.
# This field is only populated if the workflow is closed.
  sig { void }
  def clear_execution_duration
  end

  # Contains information about the root workflow execution.
# The root workflow execution is defined as follows:
# 1. A workflow without parent workflow is its own root workflow.
# 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
# Note: workflows continued as new or reseted may or may not have parents, check examples below.
#
# Examples:
#   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 3: Workflow W1 continued as new W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
#   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
#     - The root workflow of all three workflows is W1.
#   Scenario 5: Workflow W1 is reseted, creating W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)) }
  def root_execution
  end

  # Contains information about the root workflow execution.
# The root workflow execution is defined as follows:
# 1. A workflow without parent workflow is its own root workflow.
# 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
# Note: workflows continued as new or reseted may or may not have parents, check examples below.
#
# Examples:
#   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 3: Workflow W1 continued as new W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
#   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
#     - The root workflow of all three workflows is W1.
#   Scenario 5: Workflow W1 is reseted, creating W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)).void }
  def root_execution=(value)
  end

  # Contains information about the root workflow execution.
# The root workflow execution is defined as follows:
# 1. A workflow without parent workflow is its own root workflow.
# 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
# Note: workflows continued as new or reseted may or may not have parents, check examples below.
#
# Examples:
#   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
#     - The root workflow of all three workflows is W1.
#   Scenario 3: Workflow W1 continued as new W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
#   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
#     - The root workflow of all three workflows is W1.
#   Scenario 5: Workflow W1 is reseted, creating W2.
#     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  sig { void }
  def clear_root_execution
  end

  # The currently assigned build ID for this execution. Presence of this value means worker versioning is used
# for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
# when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
# again, the assigned build ID may change according to the latest versioning rules.
# Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
# this execution.
  sig { returns(String) }
  def assigned_build_id
  end

  # The currently assigned build ID for this execution. Presence of this value means worker versioning is used
# for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
# when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
# again, the assigned build ID may change according to the latest versioning rules.
# Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
# this execution.
  sig { params(value: String).void }
  def assigned_build_id=(value)
  end

  # The currently assigned build ID for this execution. Presence of this value means worker versioning is used
# for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
# when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
# again, the assigned build ID may change according to the latest versioning rules.
# Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
# this execution.
  sig { void }
  def clear_assigned_build_id
  end

  # Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
# of using the assignment rules.
  sig { returns(String) }
  def inherited_build_id
  end

  # Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
# of using the assignment rules.
  sig { params(value: String).void }
  def inherited_build_id=(value)
  end

  # Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
# of using the assignment rules.
  sig { void }
  def clear_inherited_build_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::WorkflowExecutionConfig
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::WorkflowExecutionConfig) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::WorkflowExecutionConfig).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::WorkflowExecutionConfig) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::WorkflowExecutionConfig, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      task_queue: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue),
      workflow_execution_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_run_timeout: T.nilable(Google::Protobuf::Duration),
      default_workflow_task_timeout: T.nilable(Google::Protobuf::Duration),
      user_metadata: T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)
    ).void
  end
  def initialize(
    task_queue: nil,
    workflow_execution_timeout: nil,
    workflow_run_timeout: nil,
    default_workflow_task_timeout: nil,
    user_metadata: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)) }
  def task_queue
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)).void }
  def task_queue=(value)
  end

  sig { void }
  def clear_task_queue
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_execution_timeout
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_execution_timeout=(value)
  end

  sig { void }
  def clear_workflow_execution_timeout
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_run_timeout
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_run_timeout=(value)
  end

  sig { void }
  def clear_workflow_run_timeout
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def default_workflow_task_timeout
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def default_workflow_task_timeout=(value)
  end

  sig { void }
  def clear_default_workflow_task_timeout
  end

  # User metadata provided on start workflow.
  sig { returns(T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)) }
  def user_metadata
  end

  # User metadata provided on start workflow.
  sig { params(value: T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)).void }
  def user_metadata=(value)
  end

  # User metadata provided on start workflow.
  sig { void }
  def clear_user_metadata
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::PendingActivityInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::PendingActivityInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingActivityInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::PendingActivityInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingActivityInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      activity_id: T.nilable(String),
      activity_type: T.nilable(Temporalio::Api::Common::V1::ActivityType),
      state: T.nilable(T.any(Symbol, String, Integer)),
      heartbeat_details: T.nilable(Temporalio::Api::Common::V1::Payloads),
      last_heartbeat_time: T.nilable(Google::Protobuf::Timestamp),
      last_started_time: T.nilable(Google::Protobuf::Timestamp),
      attempt: T.nilable(Integer),
      maximum_attempts: T.nilable(Integer),
      scheduled_time: T.nilable(Google::Protobuf::Timestamp),
      expiration_time: T.nilable(Google::Protobuf::Timestamp),
      last_failure: T.nilable(Temporalio::Api::Failure::V1::Failure),
      last_worker_identity: T.nilable(String),
      use_workflow_build_id: T.nilable(Google::Protobuf::Empty),
      last_independently_assigned_build_id: T.nilable(String),
      last_worker_version_stamp: T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp)
    ).void
  end
  def initialize(
    activity_id: "",
    activity_type: nil,
    state: :PENDING_ACTIVITY_STATE_UNSPECIFIED,
    heartbeat_details: nil,
    last_heartbeat_time: nil,
    last_started_time: nil,
    attempt: 0,
    maximum_attempts: 0,
    scheduled_time: nil,
    expiration_time: nil,
    last_failure: nil,
    last_worker_identity: "",
    use_workflow_build_id: nil,
    last_independently_assigned_build_id: "",
    last_worker_version_stamp: nil
  )
  end

  sig { returns(String) }
  def activity_id
  end

  sig { params(value: String).void }
  def activity_id=(value)
  end

  sig { void }
  def clear_activity_id
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::ActivityType)) }
  def activity_type
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::ActivityType)).void }
  def activity_type=(value)
  end

  sig { void }
  def clear_activity_type
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payloads)) }
  def heartbeat_details
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payloads)).void }
  def heartbeat_details=(value)
  end

  sig { void }
  def clear_heartbeat_details
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_heartbeat_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_heartbeat_time=(value)
  end

  sig { void }
  def clear_last_heartbeat_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_started_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_started_time=(value)
  end

  sig { void }
  def clear_last_started_time
  end

  sig { returns(Integer) }
  def attempt
  end

  sig { params(value: Integer).void }
  def attempt=(value)
  end

  sig { void }
  def clear_attempt
  end

  sig { returns(Integer) }
  def maximum_attempts
  end

  sig { params(value: Integer).void }
  def maximum_attempts=(value)
  end

  sig { void }
  def clear_maximum_attempts
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def scheduled_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def scheduled_time=(value)
  end

  sig { void }
  def clear_scheduled_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def expiration_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def expiration_time=(value)
  end

  sig { void }
  def clear_expiration_time
  end

  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def last_failure
  end

  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def last_failure=(value)
  end

  sig { void }
  def clear_last_failure
  end

  sig { returns(String) }
  def last_worker_identity
  end

  sig { params(value: String).void }
  def last_worker_identity=(value)
  end

  sig { void }
  def clear_last_worker_identity
  end

  # When present, it means this activity is assigned to the build ID of its workflow.
  sig { returns(T.nilable(Google::Protobuf::Empty)) }
  def use_workflow_build_id
  end

  # When present, it means this activity is assigned to the build ID of its workflow.
  sig { params(value: T.nilable(Google::Protobuf::Empty)).void }
  def use_workflow_build_id=(value)
  end

  # When present, it means this activity is assigned to the build ID of its workflow.
  sig { void }
  def clear_use_workflow_build_id
  end

  # This means the activity is independently versioned and not bound to the build ID of its workflow.
# The activity will use the build id in this field instead.
# If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
# rules.
  sig { returns(String) }
  def last_independently_assigned_build_id
  end

  # This means the activity is independently versioned and not bound to the build ID of its workflow.
# The activity will use the build id in this field instead.
# If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
# rules.
  sig { params(value: String).void }
  def last_independently_assigned_build_id=(value)
  end

  # This means the activity is independently versioned and not bound to the build ID of its workflow.
# The activity will use the build id in this field instead.
# If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
# rules.
  sig { void }
  def clear_last_independently_assigned_build_id
  end

  # The version stamp of the worker to whom this activity was most recently dispatched
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp)) }
  def last_worker_version_stamp
  end

  # The version stamp of the worker to whom this activity was most recently dispatched
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkerVersionStamp)).void }
  def last_worker_version_stamp=(value)
  end

  # The version stamp of the worker to whom this activity was most recently dispatched
  sig { void }
  def clear_last_worker_version_stamp
  end

  sig { returns(T.nilable(Symbol)) }
  def assigned_build_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::PendingChildExecutionInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::PendingChildExecutionInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingChildExecutionInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::PendingChildExecutionInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingChildExecutionInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_id: T.nilable(String),
      run_id: T.nilable(String),
      workflow_type_name: T.nilable(String),
      initiated_id: T.nilable(Integer),
      parent_close_policy: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    workflow_id: "",
    run_id: "",
    workflow_type_name: "",
    initiated_id: 0,
    parent_close_policy: :PARENT_CLOSE_POLICY_UNSPECIFIED
  )
  end

  sig { returns(String) }
  def workflow_id
  end

  sig { params(value: String).void }
  def workflow_id=(value)
  end

  sig { void }
  def clear_workflow_id
  end

  sig { returns(String) }
  def run_id
  end

  sig { params(value: String).void }
  def run_id=(value)
  end

  sig { void }
  def clear_run_id
  end

  sig { returns(String) }
  def workflow_type_name
  end

  sig { params(value: String).void }
  def workflow_type_name=(value)
  end

  sig { void }
  def clear_workflow_type_name
  end

  sig { returns(Integer) }
  def initiated_id
  end

  sig { params(value: Integer).void }
  def initiated_id=(value)
  end

  sig { void }
  def clear_initiated_id
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { returns(T.any(Symbol, Integer)) }
  def parent_close_policy
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def parent_close_policy=(value)
  end

  # Default: PARENT_CLOSE_POLICY_TERMINATE.
  sig { void }
  def clear_parent_close_policy
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::PendingWorkflowTaskInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::PendingWorkflowTaskInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingWorkflowTaskInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::PendingWorkflowTaskInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingWorkflowTaskInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      state: T.nilable(T.any(Symbol, String, Integer)),
      scheduled_time: T.nilable(Google::Protobuf::Timestamp),
      original_scheduled_time: T.nilable(Google::Protobuf::Timestamp),
      started_time: T.nilable(Google::Protobuf::Timestamp),
      attempt: T.nilable(Integer)
    ).void
  end
  def initialize(
    state: :PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED,
    scheduled_time: nil,
    original_scheduled_time: nil,
    started_time: nil,
    attempt: 0
  )
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def scheduled_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def scheduled_time=(value)
  end

  sig { void }
  def clear_scheduled_time
  end

  # original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
# Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
# In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
# some threshold, the workflow task will be forced timeout.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def original_scheduled_time
  end

  # original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
# Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
# In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
# some threshold, the workflow task will be forced timeout.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def original_scheduled_time=(value)
  end

  # original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
# Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
# In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
# some threshold, the workflow task will be forced timeout.
  sig { void }
  def clear_original_scheduled_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def started_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def started_time=(value)
  end

  sig { void }
  def clear_started_time
  end

  sig { returns(Integer) }
  def attempt
  end

  sig { params(value: Integer).void }
  def attempt=(value)
  end

  sig { void }
  def clear_attempt
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::ResetPoints
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::ResetPoints) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::ResetPoints).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::ResetPoints) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::ResetPoints, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      points: T.nilable(T::Array[T.nilable(Temporalio::Api::Workflow::V1::ResetPointInfo)])
    ).void
  end
  def initialize(
    points: []
  )
  end

  sig { returns(T::Array[T.nilable(Temporalio::Api::Workflow::V1::ResetPointInfo)]) }
  def points
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def points=(value)
  end

  sig { void }
  def clear_points
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# ResetPointInfo records the workflow event id that is the first one processed by a given
# build id or binary checksum. A new reset point will be created if either build id or binary
# checksum changes (although in general only one or the other will be used at a time).
class Temporalio::Api::Workflow::V1::ResetPointInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::ResetPointInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::ResetPointInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::ResetPointInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::ResetPointInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      build_id: T.nilable(String),
      binary_checksum: T.nilable(String),
      run_id: T.nilable(String),
      first_workflow_task_completed_id: T.nilable(Integer),
      create_time: T.nilable(Google::Protobuf::Timestamp),
      expire_time: T.nilable(Google::Protobuf::Timestamp),
      resettable: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    build_id: "",
    binary_checksum: "",
    run_id: "",
    first_workflow_task_completed_id: 0,
    create_time: nil,
    expire_time: nil,
    resettable: false
  )
  end

  # Worker build id.
  sig { returns(String) }
  def build_id
  end

  # Worker build id.
  sig { params(value: String).void }
  def build_id=(value)
  end

  # Worker build id.
  sig { void }
  def clear_build_id
  end

  # A worker binary version identifier (deprecated).
  sig { returns(String) }
  def binary_checksum
  end

  # A worker binary version identifier (deprecated).
  sig { params(value: String).void }
  def binary_checksum=(value)
  end

  # A worker binary version identifier (deprecated).
  sig { void }
  def clear_binary_checksum
  end

  # The first run ID in the execution chain that was touched by this worker build.
  sig { returns(String) }
  def run_id
  end

  # The first run ID in the execution chain that was touched by this worker build.
  sig { params(value: String).void }
  def run_id=(value)
  end

  # The first run ID in the execution chain that was touched by this worker build.
  sig { void }
  def clear_run_id
  end

  # Event ID of the first WorkflowTaskCompleted event processed by this worker build.
  sig { returns(Integer) }
  def first_workflow_task_completed_id
  end

  # Event ID of the first WorkflowTaskCompleted event processed by this worker build.
  sig { params(value: Integer).void }
  def first_workflow_task_completed_id=(value)
  end

  # Event ID of the first WorkflowTaskCompleted event processed by this worker build.
  sig { void }
  def clear_first_workflow_task_completed_id
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def create_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def create_time=(value)
  end

  sig { void }
  def clear_create_time
  end

  # (-- api-linter: core::0214::resource-expiry=disabled
#     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
# The time that the run is deleted due to retention.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def expire_time
  end

  # (-- api-linter: core::0214::resource-expiry=disabled
#     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
# The time that the run is deleted due to retention.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def expire_time=(value)
  end

  # (-- api-linter: core::0214::resource-expiry=disabled
#     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
# The time that the run is deleted due to retention.
  sig { void }
  def clear_expire_time
  end

  # false if the reset point has pending childWFs/reqCancels/signalExternals.
  sig { returns(T::Boolean) }
  def resettable
  end

  # false if the reset point has pending childWFs/reqCancels/signalExternals.
  sig { params(value: T::Boolean).void }
  def resettable=(value)
  end

  # false if the reset point has pending childWFs/reqCancels/signalExternals.
  sig { void }
  def clear_resettable
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# NewWorkflowExecutionInfo is a shared message that encapsulates all the
# required arguments to starting a workflow in different contexts.
class Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_id: T.nilable(String),
      workflow_type: T.nilable(Temporalio::Api::Common::V1::WorkflowType),
      task_queue: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue),
      input: T.nilable(Temporalio::Api::Common::V1::Payloads),
      workflow_execution_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_run_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_task_timeout: T.nilable(Google::Protobuf::Duration),
      workflow_id_reuse_policy: T.nilable(T.any(Symbol, String, Integer)),
      retry_policy: T.nilable(Temporalio::Api::Common::V1::RetryPolicy),
      cron_schedule: T.nilable(String),
      memo: T.nilable(Temporalio::Api::Common::V1::Memo),
      search_attributes: T.nilable(Temporalio::Api::Common::V1::SearchAttributes),
      header: T.nilable(Temporalio::Api::Common::V1::Header),
      user_metadata: T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)
    ).void
  end
  def initialize(
    workflow_id: "",
    workflow_type: nil,
    task_queue: nil,
    input: nil,
    workflow_execution_timeout: nil,
    workflow_run_timeout: nil,
    workflow_task_timeout: nil,
    workflow_id_reuse_policy: :WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED,
    retry_policy: nil,
    cron_schedule: "",
    memo: nil,
    search_attributes: nil,
    header: nil,
    user_metadata: nil
  )
  end

  sig { returns(String) }
  def workflow_id
  end

  sig { params(value: String).void }
  def workflow_id=(value)
  end

  sig { void }
  def clear_workflow_id
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowType)) }
  def workflow_type
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowType)).void }
  def workflow_type=(value)
  end

  sig { void }
  def clear_workflow_type
  end

  sig { returns(T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)) }
  def task_queue
  end

  sig { params(value: T.nilable(Temporalio::Api::TaskQueue::V1::TaskQueue)).void }
  def task_queue=(value)
  end

  sig { void }
  def clear_task_queue
  end

  # Serialized arguments to the workflow.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Payloads)) }
  def input
  end

  # Serialized arguments to the workflow.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Payloads)).void }
  def input=(value)
  end

  # Serialized arguments to the workflow.
  sig { void }
  def clear_input
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_execution_timeout
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_execution_timeout=(value)
  end

  # Total workflow execution timeout including retries and continue as new.
  sig { void }
  def clear_workflow_execution_timeout
  end

  # Timeout of a single workflow run.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_run_timeout
  end

  # Timeout of a single workflow run.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_run_timeout=(value)
  end

  # Timeout of a single workflow run.
  sig { void }
  def clear_workflow_run_timeout
  end

  # Timeout of a single workflow task.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_task_timeout
  end

  # Timeout of a single workflow task.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_task_timeout=(value)
  end

  # Timeout of a single workflow task.
  sig { void }
  def clear_workflow_task_timeout
  end

  # Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { returns(T.any(Symbol, Integer)) }
  def workflow_id_reuse_policy
  end

  # Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def workflow_id_reuse_policy=(value)
  end

  # Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  sig { void }
  def clear_workflow_id_reuse_policy
  end

  # The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
  sig { returns(T.nilable(Temporalio::Api::Common::V1::RetryPolicy)) }
  def retry_policy
  end

  # The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::RetryPolicy)).void }
  def retry_policy=(value)
  end

  # The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
  sig { void }
  def clear_retry_policy
  end

  # See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  sig { returns(String) }
  def cron_schedule
  end

  # See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  sig { params(value: String).void }
  def cron_schedule=(value)
  end

  # See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  sig { void }
  def clear_cron_schedule
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Memo)) }
  def memo
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Memo)).void }
  def memo=(value)
  end

  sig { void }
  def clear_memo
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::SearchAttributes)) }
  def search_attributes
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::SearchAttributes)).void }
  def search_attributes=(value)
  end

  sig { void }
  def clear_search_attributes
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Header)) }
  def header
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Header)).void }
  def header=(value)
  end

  sig { void }
  def clear_header
  end

  # Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
# for use by user interfaces to display the fixed as-of-start summary and details of the
# workflow.
  sig { returns(T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)) }
  def user_metadata
  end

  # Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
# for use by user interfaces to display the fixed as-of-start summary and details of the
# workflow.
  sig { params(value: T.nilable(Temporalio::Api::Sdk::V1::UserMetadata)).void }
  def user_metadata=(value)
  end

  # Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
# for use by user interfaces to display the fixed as-of-start summary and details of the
# workflow.
  sig { void }
  def clear_user_metadata
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# CallbackInfo contains the state of an attached workflow callback.
class Temporalio::Api::Workflow::V1::CallbackInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::CallbackInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::CallbackInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      callback: T.nilable(Temporalio::Api::Common::V1::Callback),
      trigger: T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::Trigger),
      registration_time: T.nilable(Google::Protobuf::Timestamp),
      state: T.nilable(T.any(Symbol, String, Integer)),
      attempt: T.nilable(Integer),
      last_attempt_complete_time: T.nilable(Google::Protobuf::Timestamp),
      last_attempt_failure: T.nilable(Temporalio::Api::Failure::V1::Failure),
      next_attempt_schedule_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    callback: nil,
    trigger: nil,
    registration_time: nil,
    state: :CALLBACK_STATE_UNSPECIFIED,
    attempt: 0,
    last_attempt_complete_time: nil,
    last_attempt_failure: nil,
    next_attempt_schedule_time: nil
  )
  end

  # Information on how this callback should be invoked (e.g. its URL and type).
  sig { returns(T.nilable(Temporalio::Api::Common::V1::Callback)) }
  def callback
  end

  # Information on how this callback should be invoked (e.g. its URL and type).
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Callback)).void }
  def callback=(value)
  end

  # Information on how this callback should be invoked (e.g. its URL and type).
  sig { void }
  def clear_callback
  end

  # Trigger for this callback.
  sig { returns(T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::Trigger)) }
  def trigger
  end

  # Trigger for this callback.
  sig { params(value: T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::Trigger)).void }
  def trigger=(value)
  end

  # Trigger for this callback.
  sig { void }
  def clear_trigger
  end

  # The time when the callback was registered.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def registration_time
  end

  # The time when the callback was registered.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def registration_time=(value)
  end

  # The time when the callback was registered.
  sig { void }
  def clear_registration_time
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  # The number of attempts made to deliver the callback.
# This number represents a minimum bound since the attempt is incremented after the callback request completes.
  sig { returns(Integer) }
  def attempt
  end

  # The number of attempts made to deliver the callback.
# This number represents a minimum bound since the attempt is incremented after the callback request completes.
  sig { params(value: Integer).void }
  def attempt=(value)
  end

  # The number of attempts made to deliver the callback.
# This number represents a minimum bound since the attempt is incremented after the callback request completes.
  sig { void }
  def clear_attempt
  end

  # The time when the last attempt completed.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_attempt_complete_time
  end

  # The time when the last attempt completed.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_attempt_complete_time=(value)
  end

  # The time when the last attempt completed.
  sig { void }
  def clear_last_attempt_complete_time
  end

  # The last attempt's failure, if any.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def last_attempt_failure
  end

  # The last attempt's failure, if any.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def last_attempt_failure=(value)
  end

  # The last attempt's failure, if any.
  sig { void }
  def clear_last_attempt_failure
  end

  # The time when the next attempt is scheduled.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def next_attempt_schedule_time
  end

  # The time when the next attempt is scheduled.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def next_attempt_schedule_time=(value)
  end

  # The time when the next attempt is scheduled.
  sig { void }
  def clear_next_attempt_schedule_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# PendingNexusOperationInfo contains the state of a pending Nexus operation.
class Temporalio::Api::Workflow::V1::PendingNexusOperationInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::PendingNexusOperationInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingNexusOperationInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::PendingNexusOperationInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::PendingNexusOperationInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      endpoint: T.nilable(String),
      service: T.nilable(String),
      operation: T.nilable(String),
      operation_id: T.nilable(String),
      schedule_to_close_timeout: T.nilable(Google::Protobuf::Duration),
      scheduled_time: T.nilable(Google::Protobuf::Timestamp),
      state: T.nilable(T.any(Symbol, String, Integer)),
      attempt: T.nilable(Integer),
      last_attempt_complete_time: T.nilable(Google::Protobuf::Timestamp),
      last_attempt_failure: T.nilable(Temporalio::Api::Failure::V1::Failure),
      next_attempt_schedule_time: T.nilable(Google::Protobuf::Timestamp),
      cancellation_info: T.nilable(Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo)
    ).void
  end
  def initialize(
    endpoint: "",
    service: "",
    operation: "",
    operation_id: "",
    schedule_to_close_timeout: nil,
    scheduled_time: nil,
    state: :PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED,
    attempt: 0,
    last_attempt_complete_time: nil,
    last_attempt_failure: nil,
    next_attempt_schedule_time: nil,
    cancellation_info: nil
  )
  end

  # Endpoint name.
# Resolved to a URL via the cluster's endpoint registry.
  sig { returns(String) }
  def endpoint
  end

  # Endpoint name.
# Resolved to a URL via the cluster's endpoint registry.
  sig { params(value: String).void }
  def endpoint=(value)
  end

  # Endpoint name.
# Resolved to a URL via the cluster's endpoint registry.
  sig { void }
  def clear_endpoint
  end

  # Service name.
  sig { returns(String) }
  def service
  end

  # Service name.
  sig { params(value: String).void }
  def service=(value)
  end

  # Service name.
  sig { void }
  def clear_service
  end

  # Operation name.
  sig { returns(String) }
  def operation
  end

  # Operation name.
  sig { params(value: String).void }
  def operation=(value)
  end

  # Operation name.
  sig { void }
  def clear_operation
  end

  # Operation ID. Only set for asynchronous operations after a successful StartOperation call.
  sig { returns(String) }
  def operation_id
  end

  # Operation ID. Only set for asynchronous operations after a successful StartOperation call.
  sig { params(value: String).void }
  def operation_id=(value)
  end

  # Operation ID. Only set for asynchronous operations after a successful StartOperation call.
  sig { void }
  def clear_operation_id
  end

  # Schedule-to-close timeout for this operation.
# This is the only timeout settable by a workflow.
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def schedule_to_close_timeout
  end

  # Schedule-to-close timeout for this operation.
# This is the only timeout settable by a workflow.
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def schedule_to_close_timeout=(value)
  end

  # Schedule-to-close timeout for this operation.
# This is the only timeout settable by a workflow.
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: "to" is used to indicate interval. --)
  sig { void }
  def clear_schedule_to_close_timeout
  end

  # The time when the operation was scheduled.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def scheduled_time
  end

  # The time when the operation was scheduled.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def scheduled_time=(value)
  end

  # The time when the operation was scheduled.
  sig { void }
  def clear_scheduled_time
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  # The number of attempts made to deliver the start operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { returns(Integer) }
  def attempt
  end

  # The number of attempts made to deliver the start operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { params(value: Integer).void }
  def attempt=(value)
  end

  # The number of attempts made to deliver the start operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { void }
  def clear_attempt
  end

  # The time when the last attempt completed.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_attempt_complete_time
  end

  # The time when the last attempt completed.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_attempt_complete_time=(value)
  end

  # The time when the last attempt completed.
  sig { void }
  def clear_last_attempt_complete_time
  end

  # The last attempt's failure, if any.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def last_attempt_failure
  end

  # The last attempt's failure, if any.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def last_attempt_failure=(value)
  end

  # The last attempt's failure, if any.
  sig { void }
  def clear_last_attempt_failure
  end

  # The time when the next attempt is scheduled.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def next_attempt_schedule_time
  end

  # The time when the next attempt is scheduled.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def next_attempt_schedule_time=(value)
  end

  # The time when the next attempt is scheduled.
  sig { void }
  def clear_next_attempt_schedule_time
  end

  sig { returns(T.nilable(Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo)) }
  def cancellation_info
  end

  sig { params(value: T.nilable(Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo)).void }
  def cancellation_info=(value)
  end

  sig { void }
  def clear_cancellation_info
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
class Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::NexusOperationCancellationInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      requested_time: T.nilable(Google::Protobuf::Timestamp),
      state: T.nilable(T.any(Symbol, String, Integer)),
      attempt: T.nilable(Integer),
      last_attempt_complete_time: T.nilable(Google::Protobuf::Timestamp),
      last_attempt_failure: T.nilable(Temporalio::Api::Failure::V1::Failure),
      next_attempt_schedule_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    requested_time: nil,
    state: :NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED,
    attempt: 0,
    last_attempt_complete_time: nil,
    last_attempt_failure: nil,
    next_attempt_schedule_time: nil
  )
  end

  # The time when cancellation was requested.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def requested_time
  end

  # The time when cancellation was requested.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def requested_time=(value)
  end

  # The time when cancellation was requested.
  sig { void }
  def clear_requested_time
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  # The number of attempts made to deliver the cancel operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { returns(Integer) }
  def attempt
  end

  # The number of attempts made to deliver the cancel operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { params(value: Integer).void }
  def attempt=(value)
  end

  # The number of attempts made to deliver the cancel operation request.
# This number represents a minimum bound since the attempt is incremented after the request completes.
  sig { void }
  def clear_attempt
  end

  # The time when the last attempt completed.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def last_attempt_complete_time
  end

  # The time when the last attempt completed.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def last_attempt_complete_time=(value)
  end

  # The time when the last attempt completed.
  sig { void }
  def clear_last_attempt_complete_time
  end

  # The last attempt's failure, if any.
  sig { returns(T.nilable(Temporalio::Api::Failure::V1::Failure)) }
  def last_attempt_failure
  end

  # The last attempt's failure, if any.
  sig { params(value: T.nilable(Temporalio::Api::Failure::V1::Failure)).void }
  def last_attempt_failure=(value)
  end

  # The last attempt's failure, if any.
  sig { void }
  def clear_last_attempt_failure
  end

  # The time when the next attempt is scheduled.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def next_attempt_schedule_time
  end

  # The time when the next attempt is scheduled.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def next_attempt_schedule_time=(value)
  end

  # The time when the next attempt is scheduled.
  sig { void }
  def clear_next_attempt_schedule_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Trigger for when the workflow is closed.
class Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig {void}
  def initialize; end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Workflow::V1::CallbackInfo::Trigger
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Workflow::V1::CallbackInfo::Trigger) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo::Trigger).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Workflow::V1::CallbackInfo::Trigger) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Workflow::V1::CallbackInfo::Trigger, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_closed: T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed)
    ).void
  end
  def initialize(
    workflow_closed: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed)) }
  def workflow_closed
  end

  sig { params(value: T.nilable(Temporalio::Api::Workflow::V1::CallbackInfo::WorkflowClosed)).void }
  def workflow_closed=(value)
  end

  sig { void }
  def clear_workflow_closed
  end

  sig { returns(T.nilable(Symbol)) }
  def variant
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end
