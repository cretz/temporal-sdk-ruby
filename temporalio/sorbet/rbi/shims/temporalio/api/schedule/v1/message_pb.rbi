# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/api/schedule/v1/message.proto
# typed: strict

# CalendarSpec describes an event specification relative to the calendar,
# similar to a traditional cron specification, but with labeled fields. Each
# field can be one of:
#   *: matches always
#   x: matches when the field equals x
#   x/y : matches when the field equals x+n*y where n is an integer
#   x-z: matches when the field is between x and z inclusive
#   w,x,y,...: matches when the field is one of the listed values
# Each x, y, z, ... is either a decimal integer, or a month or day of week name
# or abbreviation (in the appropriate fields).
# A timestamp matches if all fields match.
# Note that fields have different default values, for convenience.
# Note that the special case that some cron implementations have for treating
# day_of_month and day_of_week as "or" instead of "and" when both are set is
# not implemented.
# day_of_week can accept 0 or 7 as Sunday
# CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
# returned if you describe the schedule.
class Temporalio::Api::Schedule::V1::CalendarSpec
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::CalendarSpec) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::CalendarSpec).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::CalendarSpec) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::CalendarSpec, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      second: T.nilable(String),
      minute: T.nilable(String),
      hour: T.nilable(String),
      day_of_month: T.nilable(String),
      month: T.nilable(String),
      year: T.nilable(String),
      day_of_week: T.nilable(String),
      comment: T.nilable(String)
    ).void
  end
  def initialize(
    second: "",
    minute: "",
    hour: "",
    day_of_month: "",
    month: "",
    year: "",
    day_of_week: "",
    comment: ""
  )
  end

  # Expression to match seconds. Default: 0
  sig { returns(String) }
  def second
  end

  # Expression to match seconds. Default: 0
  sig { params(value: String).void }
  def second=(value)
  end

  # Expression to match seconds. Default: 0
  sig { void }
  def clear_second
  end

  # Expression to match minutes. Default: 0
  sig { returns(String) }
  def minute
  end

  # Expression to match minutes. Default: 0
  sig { params(value: String).void }
  def minute=(value)
  end

  # Expression to match minutes. Default: 0
  sig { void }
  def clear_minute
  end

  # Expression to match hours. Default: 0
  sig { returns(String) }
  def hour
  end

  # Expression to match hours. Default: 0
  sig { params(value: String).void }
  def hour=(value)
  end

  # Expression to match hours. Default: 0
  sig { void }
  def clear_hour
  end

  # Expression to match days of the month. Default: *
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { returns(String) }
  def day_of_month
  end

  # Expression to match days of the month. Default: *
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { params(value: String).void }
  def day_of_month=(value)
  end

  # Expression to match days of the month. Default: *
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { void }
  def clear_day_of_month
  end

  # Expression to match months. Default: *
  sig { returns(String) }
  def month
  end

  # Expression to match months. Default: *
  sig { params(value: String).void }
  def month=(value)
  end

  # Expression to match months. Default: *
  sig { void }
  def clear_month
  end

  # Expression to match years. Default: *
  sig { returns(String) }
  def year
  end

  # Expression to match years. Default: *
  sig { params(value: String).void }
  def year=(value)
  end

  # Expression to match years. Default: *
  sig { void }
  def clear_year
  end

  # Expression to match days of the week. Default: *
  sig { returns(String) }
  def day_of_week
  end

  # Expression to match days of the week. Default: *
  sig { params(value: String).void }
  def day_of_week=(value)
  end

  # Expression to match days of the week. Default: *
  sig { void }
  def clear_day_of_week
  end

  # Free-form comment describing the intention of this spec.
  sig { returns(String) }
  def comment
  end

  # Free-form comment describing the intention of this spec.
  sig { params(value: String).void }
  def comment=(value)
  end

  # Free-form comment describing the intention of this spec.
  sig { void }
  def clear_comment
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Range represents a set of integer values, used to match fields of a calendar
# time in StructuredCalendarSpec. If end < start, then end is interpreted as
# equal to start. This means you can use a Range with start set to a value, and
# end and step unset (defaulting to 0) to represent a single value.
class Temporalio::Api::Schedule::V1::Range
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::Range) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::Range).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::Range) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::Range, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      start: T.nilable(Integer),
      end: T.nilable(Integer),
      step: T.nilable(Integer)
    ).void
  end
  def initialize(
    start: 0,
    end: 0,
    step: 0
  )
  end

  # Start of range (inclusive).
  sig { returns(Integer) }
  def start
  end

  # Start of range (inclusive).
  sig { params(value: Integer).void }
  def start=(value)
  end

  # Start of range (inclusive).
  sig { void }
  def clear_start
  end

  # End of range (inclusive).
  sig { returns(Integer) }
  def end
  end

  # End of range (inclusive).
  sig { params(value: Integer).void }
  def end=(value)
  end

  # End of range (inclusive).
  sig { void }
  def clear_end
  end

  # Step (optional, default 1).
  sig { returns(Integer) }
  def step
  end

  # Step (optional, default 1).
  sig { params(value: Integer).void }
  def step=(value)
  end

  # Step (optional, default 1).
  sig { void }
  def clear_step
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# StructuredCalendarSpec describes an event specification relative to the
# calendar, in a form that's easy to work with programmatically. Each field can
# be one or more ranges.
# A timestamp matches if at least one range of each field matches the
# corresponding fields of the timestamp, except for year: if year is missing,
# that means all years match. For all fields besides year, at least one Range
# must be present to match anything.
# TODO: add relative-to-end-of-month
# TODO: add nth day-of-week in month
class Temporalio::Api::Schedule::V1::StructuredCalendarSpec
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::StructuredCalendarSpec) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::StructuredCalendarSpec).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::StructuredCalendarSpec) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::StructuredCalendarSpec, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      second: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      minute: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      hour: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      day_of_month: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      month: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      year: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      day_of_week: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]),
      comment: T.nilable(String)
    ).void
  end
  def initialize(
    second: [],
    minute: [],
    hour: [],
    day_of_month: [],
    month: [],
    year: [],
    day_of_week: [],
    comment: ""
  )
  end

  # Match seconds (0-59)
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def second
  end

  # Match seconds (0-59)
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def second=(value)
  end

  # Match seconds (0-59)
  sig { void }
  def clear_second
  end

  # Match minutes (0-59)
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def minute
  end

  # Match minutes (0-59)
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def minute=(value)
  end

  # Match minutes (0-59)
  sig { void }
  def clear_minute
  end

  # Match hours (0-23)
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def hour
  end

  # Match hours (0-23)
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def hour=(value)
  end

  # Match hours (0-23)
  sig { void }
  def clear_hour
  end

  # Match days of the month (1-31)
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def day_of_month
  end

  # Match days of the month (1-31)
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def day_of_month=(value)
  end

  # Match days of the month (1-31)
# (-- api-linter: core::0140::prepositions=disabled
#     aip.dev/not-precedent: standard name of field --)
  sig { void }
  def clear_day_of_month
  end

  # Match months (1-12)
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def month
  end

  # Match months (1-12)
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def month=(value)
  end

  # Match months (1-12)
  sig { void }
  def clear_month
  end

  # Match years.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def year
  end

  # Match years.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def year=(value)
  end

  # Match years.
  sig { void }
  def clear_year
  end

  # Match days of the week (0-6; 0 is Sunday).
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::Range)]) }
  def day_of_week
  end

  # Match days of the week (0-6; 0 is Sunday).
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def day_of_week=(value)
  end

  # Match days of the week (0-6; 0 is Sunday).
  sig { void }
  def clear_day_of_week
  end

  # Free-form comment describing the intention of this spec.
  sig { returns(String) }
  def comment
  end

  # Free-form comment describing the intention of this spec.
  sig { params(value: String).void }
  def comment=(value)
  end

  # Free-form comment describing the intention of this spec.
  sig { void }
  def clear_comment
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# IntervalSpec matches times that can be expressed as:
# epoch + n * interval + phase
# where n is an integer.
# phase defaults to zero if missing. interval is required.
# Both interval and phase must be non-negative and are truncated to the nearest
# second before any calculations.
# For example, an interval of 1 hour with phase of zero would match every hour,
# on the hour. The same interval but a phase of 19 minutes would match every
# xx:19:00. An interval of 28 days with phase zero would match
# 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
# days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
class Temporalio::Api::Schedule::V1::IntervalSpec
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::IntervalSpec) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::IntervalSpec).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::IntervalSpec) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::IntervalSpec, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      interval: T.nilable(Google::Protobuf::Duration),
      phase: T.nilable(Google::Protobuf::Duration)
    ).void
  end
  def initialize(
    interval: nil,
    phase: nil
  )
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def interval
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def interval=(value)
  end

  sig { void }
  def clear_interval
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def phase
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def phase=(value)
  end

  sig { void }
  def clear_phase
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# ScheduleSpec is a complete description of a set of absolute timestamps
# (possibly infinite) that an action should occur at. The meaning of a
# ScheduleSpec depends only on its contents and never changes, except that the
# definition of a time zone can change over time (most commonly, when daylight
# saving time policy changes for an area). To create a totally self-contained
# ScheduleSpec, use UTC or include timezone_data.
#
# For input, you can provide zero or more of: structured_calendar, calendar,
# cron_string, interval, and exclude_structured_calendar, and all of them will
# be used (the schedule will take action at the union of all of their times,
# minus the ones that match exclude_structured_calendar).
#
# On input, calendar and cron_string fields will be compiled into
# structured_calendar (and maybe interval and timezone_name), so if you
# Describe a schedule, you'll see only structured_calendar, interval, etc.
#
# If a spec has no matching times after the current time, then the schedule
# will be subject to automatic deletion (after several days).
class Temporalio::Api::Schedule::V1::ScheduleSpec
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleSpec) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleSpec).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleSpec) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleSpec, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      structured_calendar: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::StructuredCalendarSpec)]),
      cron_string: T.nilable(T::Array[String]),
      calendar: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::CalendarSpec)]),
      interval: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::IntervalSpec)]),
      exclude_calendar: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::CalendarSpec)]),
      exclude_structured_calendar: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::StructuredCalendarSpec)]),
      start_time: T.nilable(Google::Protobuf::Timestamp),
      end_time: T.nilable(Google::Protobuf::Timestamp),
      jitter: T.nilable(Google::Protobuf::Duration),
      timezone_name: T.nilable(String),
      timezone_data: T.nilable(String)
    ).void
  end
  def initialize(
    structured_calendar: [],
    cron_string: [],
    calendar: [],
    interval: [],
    exclude_calendar: [],
    exclude_structured_calendar: [],
    start_time: nil,
    end_time: nil,
    jitter: nil,
    timezone_name: "",
    timezone_data: ""
  )
  end

  # Calendar-based specifications of times.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::StructuredCalendarSpec)]) }
  def structured_calendar
  end

  # Calendar-based specifications of times.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def structured_calendar=(value)
  end

  # Calendar-based specifications of times.
  sig { void }
  def clear_structured_calendar
  end

  # cron_string holds a traditional cron specification as a string. It
# accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
# same way as CalendarSpec.
# 5 fields:         minute, hour, day_of_month, month, day_of_week
# 6 fields:         minute, hour, day_of_month, month, day_of_week, year
# 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
# If year is not given, it defaults to *. If second is not given, it
# defaults to 0.
# Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
# accepted instead of the 5-7 time fields.
# Optionally, the string can be preceded by CRON_TZ=<timezone name> or
# TZ=<timezone name>, which will get copied to timezone_name. (There must
# not also be a timezone_name present.)
# Optionally "#" followed by a comment can appear at the end of the string.
# Note that the special case that some cron implementations have for
# treating day_of_month and day_of_week as "or" instead of "and" when both
# are set is not implemented.
# @every <interval>[/<phase>] is accepted and gets compiled into an
# IntervalSpec instead. <interval> and <phase> should be a decimal integer
# with a unit suffix s, m, h, or d.
  sig { returns(T::Array[String]) }
  def cron_string
  end

  # cron_string holds a traditional cron specification as a string. It
# accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
# same way as CalendarSpec.
# 5 fields:         minute, hour, day_of_month, month, day_of_week
# 6 fields:         minute, hour, day_of_month, month, day_of_week, year
# 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
# If year is not given, it defaults to *. If second is not given, it
# defaults to 0.
# Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
# accepted instead of the 5-7 time fields.
# Optionally, the string can be preceded by CRON_TZ=<timezone name> or
# TZ=<timezone name>, which will get copied to timezone_name. (There must
# not also be a timezone_name present.)
# Optionally "#" followed by a comment can appear at the end of the string.
# Note that the special case that some cron implementations have for
# treating day_of_month and day_of_week as "or" instead of "and" when both
# are set is not implemented.
# @every <interval>[/<phase>] is accepted and gets compiled into an
# IntervalSpec instead. <interval> and <phase> should be a decimal integer
# with a unit suffix s, m, h, or d.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def cron_string=(value)
  end

  # cron_string holds a traditional cron specification as a string. It
# accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
# same way as CalendarSpec.
# 5 fields:         minute, hour, day_of_month, month, day_of_week
# 6 fields:         minute, hour, day_of_month, month, day_of_week, year
# 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
# If year is not given, it defaults to *. If second is not given, it
# defaults to 0.
# Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
# accepted instead of the 5-7 time fields.
# Optionally, the string can be preceded by CRON_TZ=<timezone name> or
# TZ=<timezone name>, which will get copied to timezone_name. (There must
# not also be a timezone_name present.)
# Optionally "#" followed by a comment can appear at the end of the string.
# Note that the special case that some cron implementations have for
# treating day_of_month and day_of_week as "or" instead of "and" when both
# are set is not implemented.
# @every <interval>[/<phase>] is accepted and gets compiled into an
# IntervalSpec instead. <interval> and <phase> should be a decimal integer
# with a unit suffix s, m, h, or d.
  sig { void }
  def clear_cron_string
  end

  # Calendar-based specifications of times.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::CalendarSpec)]) }
  def calendar
  end

  # Calendar-based specifications of times.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def calendar=(value)
  end

  # Calendar-based specifications of times.
  sig { void }
  def clear_calendar
  end

  # Interval-based specifications of times.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::IntervalSpec)]) }
  def interval
  end

  # Interval-based specifications of times.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def interval=(value)
  end

  # Interval-based specifications of times.
  sig { void }
  def clear_interval
  end

  # Any timestamps matching any of exclude_* will be skipped.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::CalendarSpec)]) }
  def exclude_calendar
  end

  # Any timestamps matching any of exclude_* will be skipped.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def exclude_calendar=(value)
  end

  # Any timestamps matching any of exclude_* will be skipped.
  sig { void }
  def clear_exclude_calendar
  end

  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::StructuredCalendarSpec)]) }
  def exclude_structured_calendar
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def exclude_structured_calendar=(value)
  end

  sig { void }
  def clear_exclude_structured_calendar
  end

  # If start_time is set, any timestamps before start_time will be skipped.
# (Together, start_time and end_time make an inclusive interval.)
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def start_time
  end

  # If start_time is set, any timestamps before start_time will be skipped.
# (Together, start_time and end_time make an inclusive interval.)
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def start_time=(value)
  end

  # If start_time is set, any timestamps before start_time will be skipped.
# (Together, start_time and end_time make an inclusive interval.)
  sig { void }
  def clear_start_time
  end

  # If end_time is set, any timestamps after end_time will be skipped.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def end_time
  end

  # If end_time is set, any timestamps after end_time will be skipped.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def end_time=(value)
  end

  # If end_time is set, any timestamps after end_time will be skipped.
  sig { void }
  def clear_end_time
  end

  # All timestamps will be incremented by a random value from 0 to this
# amount of jitter. Default: 0
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def jitter
  end

  # All timestamps will be incremented by a random value from 0 to this
# amount of jitter. Default: 0
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def jitter=(value)
  end

  # All timestamps will be incremented by a random value from 0 to this
# amount of jitter. Default: 0
  sig { void }
  def clear_jitter
  end

  # Time zone to interpret all calendar-based specs in.
#
# If unset, defaults to UTC. We recommend using UTC for your application if
# at all possible, to avoid various surprising properties of time zones.
#
# Time zones may be provided by name, corresponding to names in the IANA
# time zone database (see https://www.iana.org/time-zones). The definition
# will be loaded by the Temporal server from the environment it runs in.
#
# If your application requires more control over the time zone definition
# used, it may pass in a complete definition in the form of a TZif file
# from the time zone database. If present, this will be used instead of
# loading anything from the environment. You are then responsible for
# updating timezone_data when the definition changes.
#
# Calendar spec matching is based on literal matching of the clock time
# with no special handling of DST: if you write a calendar spec that fires
# at 2:30am and specify a time zone that follows DST, that action will not
# be triggered on the day that has no 2:30am. Similarly, an action that
# fires at 1:30am will be triggered twice on the day that has two 1:30s.
#
# Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
  sig { returns(String) }
  def timezone_name
  end

  # Time zone to interpret all calendar-based specs in.
#
# If unset, defaults to UTC. We recommend using UTC for your application if
# at all possible, to avoid various surprising properties of time zones.
#
# Time zones may be provided by name, corresponding to names in the IANA
# time zone database (see https://www.iana.org/time-zones). The definition
# will be loaded by the Temporal server from the environment it runs in.
#
# If your application requires more control over the time zone definition
# used, it may pass in a complete definition in the form of a TZif file
# from the time zone database. If present, this will be used instead of
# loading anything from the environment. You are then responsible for
# updating timezone_data when the definition changes.
#
# Calendar spec matching is based on literal matching of the clock time
# with no special handling of DST: if you write a calendar spec that fires
# at 2:30am and specify a time zone that follows DST, that action will not
# be triggered on the day that has no 2:30am. Similarly, an action that
# fires at 1:30am will be triggered twice on the day that has two 1:30s.
#
# Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
  sig { params(value: String).void }
  def timezone_name=(value)
  end

  # Time zone to interpret all calendar-based specs in.
#
# If unset, defaults to UTC. We recommend using UTC for your application if
# at all possible, to avoid various surprising properties of time zones.
#
# Time zones may be provided by name, corresponding to names in the IANA
# time zone database (see https://www.iana.org/time-zones). The definition
# will be loaded by the Temporal server from the environment it runs in.
#
# If your application requires more control over the time zone definition
# used, it may pass in a complete definition in the form of a TZif file
# from the time zone database. If present, this will be used instead of
# loading anything from the environment. You are then responsible for
# updating timezone_data when the definition changes.
#
# Calendar spec matching is based on literal matching of the clock time
# with no special handling of DST: if you write a calendar spec that fires
# at 2:30am and specify a time zone that follows DST, that action will not
# be triggered on the day that has no 2:30am. Similarly, an action that
# fires at 1:30am will be triggered twice on the day that has two 1:30s.
#
# Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
  sig { void }
  def clear_timezone_name
  end

  sig { returns(String) }
  def timezone_data
  end

  sig { params(value: String).void }
  def timezone_data=(value)
  end

  sig { void }
  def clear_timezone_data
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::SchedulePolicies
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::SchedulePolicies) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::SchedulePolicies).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::SchedulePolicies) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::SchedulePolicies, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      overlap_policy: T.nilable(T.any(Symbol, String, Integer)),
      catchup_window: T.nilable(Google::Protobuf::Duration),
      pause_on_failure: T.nilable(T::Boolean),
      keep_original_workflow_id: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    overlap_policy: :SCHEDULE_OVERLAP_POLICY_UNSPECIFIED,
    catchup_window: nil,
    pause_on_failure: false,
    keep_original_workflow_id: false
  )
  end

  # Policy for overlaps.
# Note that this can be changed after a schedule has taken some actions,
# and some changes might produce unintuitive results. In general, the later
# policy overrides the earlier policy.
  sig { returns(T.any(Symbol, Integer)) }
  def overlap_policy
  end

  # Policy for overlaps.
# Note that this can be changed after a schedule has taken some actions,
# and some changes might produce unintuitive results. In general, the later
# policy overrides the earlier policy.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def overlap_policy=(value)
  end

  # Policy for overlaps.
# Note that this can be changed after a schedule has taken some actions,
# and some changes might produce unintuitive results. In general, the later
# policy overrides the earlier policy.
  sig { void }
  def clear_overlap_policy
  end

  # Policy for catchups:
# If the Temporal server misses an action due to one or more components
# being down, and comes back up, the action will be run if the scheduled
# time is within this window from the current time.
# This value defaults to one year, and can't be less than 10 seconds.
  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def catchup_window
  end

  # Policy for catchups:
# If the Temporal server misses an action due to one or more components
# being down, and comes back up, the action will be run if the scheduled
# time is within this window from the current time.
# This value defaults to one year, and can't be less than 10 seconds.
  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def catchup_window=(value)
  end

  # Policy for catchups:
# If the Temporal server misses an action due to one or more components
# being down, and comes back up, the action will be run if the scheduled
# time is within this window from the current time.
# This value defaults to one year, and can't be less than 10 seconds.
  sig { void }
  def clear_catchup_window
  end

  # If true, and a workflow run fails or times out, turn on "paused".
# This applies after retry policies: the full chain of retries must fail to
# trigger a pause here.
  sig { returns(T::Boolean) }
  def pause_on_failure
  end

  # If true, and a workflow run fails or times out, turn on "paused".
# This applies after retry policies: the full chain of retries must fail to
# trigger a pause here.
  sig { params(value: T::Boolean).void }
  def pause_on_failure=(value)
  end

  # If true, and a workflow run fails or times out, turn on "paused".
# This applies after retry policies: the full chain of retries must fail to
# trigger a pause here.
  sig { void }
  def clear_pause_on_failure
  end

  # If true, and the action would start a workflow, a timestamp will not be
# appended to the scheduled workflow id.
  sig { returns(T::Boolean) }
  def keep_original_workflow_id
  end

  # If true, and the action would start a workflow, a timestamp will not be
# appended to the scheduled workflow id.
  sig { params(value: T::Boolean).void }
  def keep_original_workflow_id=(value)
  end

  # If true, and the action would start a workflow, a timestamp will not be
# appended to the scheduled workflow id.
  sig { void }
  def clear_keep_original_workflow_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::ScheduleAction
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleAction) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleAction).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleAction) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleAction, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      start_workflow: T.nilable(Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo)
    ).void
  end
  def initialize(
    start_workflow: nil
  )
  end

  # All fields of NewWorkflowExecutionInfo are valid except for:
# - workflow_id_reuse_policy
# - cron_schedule
# The workflow id of the started workflow may not match this exactly,
# it may have a timestamp appended for uniqueness.
  sig { returns(T.nilable(Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo)) }
  def start_workflow
  end

  # All fields of NewWorkflowExecutionInfo are valid except for:
# - workflow_id_reuse_policy
# - cron_schedule
# The workflow id of the started workflow may not match this exactly,
# it may have a timestamp appended for uniqueness.
  sig { params(value: T.nilable(Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo)).void }
  def start_workflow=(value)
  end

  # All fields of NewWorkflowExecutionInfo are valid except for:
# - workflow_id_reuse_policy
# - cron_schedule
# The workflow id of the started workflow may not match this exactly,
# it may have a timestamp appended for uniqueness.
  sig { void }
  def clear_start_workflow
  end

  sig { returns(T.nilable(Symbol)) }
  def action
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::ScheduleActionResult
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleActionResult) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleActionResult).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleActionResult) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleActionResult, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      schedule_time: T.nilable(Google::Protobuf::Timestamp),
      actual_time: T.nilable(Google::Protobuf::Timestamp),
      start_workflow_result: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)
    ).void
  end
  def initialize(
    schedule_time: nil,
    actual_time: nil,
    start_workflow_result: nil
  )
  end

  # Time that the action was taken (according to the schedule, including jitter).
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def schedule_time
  end

  # Time that the action was taken (according to the schedule, including jitter).
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def schedule_time=(value)
  end

  # Time that the action was taken (according to the schedule, including jitter).
  sig { void }
  def clear_schedule_time
  end

  # Time that the action was taken (real time).
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def actual_time
  end

  # Time that the action was taken (real time).
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def actual_time=(value)
  end

  # Time that the action was taken (real time).
  sig { void }
  def clear_actual_time
  end

  # If action was start_workflow:
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)) }
  def start_workflow_result
  end

  # If action was start_workflow:
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)).void }
  def start_workflow_result=(value)
  end

  # If action was start_workflow:
  sig { void }
  def clear_start_workflow_result
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::ScheduleState
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleState) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleState).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleState) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleState, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      notes: T.nilable(String),
      paused: T.nilable(T::Boolean),
      limited_actions: T.nilable(T::Boolean),
      remaining_actions: T.nilable(Integer)
    ).void
  end
  def initialize(
    notes: "",
    paused: false,
    limited_actions: false,
    remaining_actions: 0
  )
  end

  # Informative human-readable message with contextual notes, e.g. the reason
# a schedule is paused. The system may overwrite this message on certain
# conditions, e.g. when pause-on-failure happens.
  sig { returns(String) }
  def notes
  end

  # Informative human-readable message with contextual notes, e.g. the reason
# a schedule is paused. The system may overwrite this message on certain
# conditions, e.g. when pause-on-failure happens.
  sig { params(value: String).void }
  def notes=(value)
  end

  # Informative human-readable message with contextual notes, e.g. the reason
# a schedule is paused. The system may overwrite this message on certain
# conditions, e.g. when pause-on-failure happens.
  sig { void }
  def clear_notes
  end

  # If true, do not take any actions based on the schedule spec.
  sig { returns(T::Boolean) }
  def paused
  end

  # If true, do not take any actions based on the schedule spec.
  sig { params(value: T::Boolean).void }
  def paused=(value)
  end

  # If true, do not take any actions based on the schedule spec.
  sig { void }
  def clear_paused
  end

  # If limited_actions is true, decrement remaining_actions after each
# action, and do not take any more scheduled actions if remaining_actions
# is zero. Actions may still be taken by explicit request (i.e. trigger
# immediately or backfill). Skipped actions (due to overlap policy) do not
# count against remaining actions.
# If a schedule has no more remaining actions, then the schedule will be
# subject to automatic deletion (after several days).
  sig { returns(T::Boolean) }
  def limited_actions
  end

  # If limited_actions is true, decrement remaining_actions after each
# action, and do not take any more scheduled actions if remaining_actions
# is zero. Actions may still be taken by explicit request (i.e. trigger
# immediately or backfill). Skipped actions (due to overlap policy) do not
# count against remaining actions.
# If a schedule has no more remaining actions, then the schedule will be
# subject to automatic deletion (after several days).
  sig { params(value: T::Boolean).void }
  def limited_actions=(value)
  end

  # If limited_actions is true, decrement remaining_actions after each
# action, and do not take any more scheduled actions if remaining_actions
# is zero. Actions may still be taken by explicit request (i.e. trigger
# immediately or backfill). Skipped actions (due to overlap policy) do not
# count against remaining actions.
# If a schedule has no more remaining actions, then the schedule will be
# subject to automatic deletion (after several days).
  sig { void }
  def clear_limited_actions
  end

  sig { returns(Integer) }
  def remaining_actions
  end

  sig { params(value: Integer).void }
  def remaining_actions=(value)
  end

  sig { void }
  def clear_remaining_actions
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      overlap_policy: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    overlap_policy: :SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
  )
  end

  # If set, override overlap policy for this one request.
  sig { returns(T.any(Symbol, Integer)) }
  def overlap_policy
  end

  # If set, override overlap policy for this one request.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def overlap_policy=(value)
  end

  # If set, override overlap policy for this one request.
  sig { void }
  def clear_overlap_policy
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::BackfillRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::BackfillRequest) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::BackfillRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::BackfillRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::BackfillRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      start_time: T.nilable(Google::Protobuf::Timestamp),
      end_time: T.nilable(Google::Protobuf::Timestamp),
      overlap_policy: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    start_time: nil,
    end_time: nil,
    overlap_policy: :SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
  )
  end

  # Time range to evaluate schedule in. Currently, this time range is
# exclusive on start_time and inclusive on end_time. (This is admittedly
# counterintuitive and it may change in the future, so to be safe, use a
# start time strictly before a scheduled time.) Also note that an action
# nominally scheduled in the interval but with jitter that pushes it after
# end_time will not be included.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def start_time
  end

  # Time range to evaluate schedule in. Currently, this time range is
# exclusive on start_time and inclusive on end_time. (This is admittedly
# counterintuitive and it may change in the future, so to be safe, use a
# start time strictly before a scheduled time.) Also note that an action
# nominally scheduled in the interval but with jitter that pushes it after
# end_time will not be included.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def start_time=(value)
  end

  # Time range to evaluate schedule in. Currently, this time range is
# exclusive on start_time and inclusive on end_time. (This is admittedly
# counterintuitive and it may change in the future, so to be safe, use a
# start time strictly before a scheduled time.) Also note that an action
# nominally scheduled in the interval but with jitter that pushes it after
# end_time will not be included.
  sig { void }
  def clear_start_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def end_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def end_time=(value)
  end

  sig { void }
  def clear_end_time
  end

  # If set, override overlap policy for this request.
  sig { returns(T.any(Symbol, Integer)) }
  def overlap_policy
  end

  # If set, override overlap policy for this request.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def overlap_policy=(value)
  end

  # If set, override overlap policy for this request.
  sig { void }
  def clear_overlap_policy
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::SchedulePatch
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::SchedulePatch) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::SchedulePatch).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::SchedulePatch) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::SchedulePatch, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      trigger_immediately: T.nilable(Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest),
      backfill_request: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::BackfillRequest)]),
      pause: T.nilable(String),
      unpause: T.nilable(String)
    ).void
  end
  def initialize(
    trigger_immediately: nil,
    backfill_request: [],
    pause: "",
    unpause: ""
  )
  end

  # If set, trigger one action immediately.
  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest)) }
  def trigger_immediately
  end

  # If set, trigger one action immediately.
  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest)).void }
  def trigger_immediately=(value)
  end

  # If set, trigger one action immediately.
  sig { void }
  def clear_trigger_immediately
  end

  # If set, runs though the specified time period(s) and takes actions as if that time
# passed by right now, all at once. The overlap policy can be overridden for the
# scope of the backfill.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::BackfillRequest)]) }
  def backfill_request
  end

  # If set, runs though the specified time period(s) and takes actions as if that time
# passed by right now, all at once. The overlap policy can be overridden for the
# scope of the backfill.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def backfill_request=(value)
  end

  # If set, runs though the specified time period(s) and takes actions as if that time
# passed by right now, all at once. The overlap policy can be overridden for the
# scope of the backfill.
  sig { void }
  def clear_backfill_request
  end

  # If set, change the state to paused or unpaused (respectively) and set the
# notes field to the value of the string.
  sig { returns(String) }
  def pause
  end

  # If set, change the state to paused or unpaused (respectively) and set the
# notes field to the value of the string.
  sig { params(value: String).void }
  def pause=(value)
  end

  # If set, change the state to paused or unpaused (respectively) and set the
# notes field to the value of the string.
  sig { void }
  def clear_pause
  end

  sig { returns(String) }
  def unpause
  end

  sig { params(value: String).void }
  def unpause=(value)
  end

  sig { void }
  def clear_unpause
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::ScheduleInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      action_count: T.nilable(Integer),
      missed_catchup_window: T.nilable(Integer),
      overlap_skipped: T.nilable(Integer),
      buffer_dropped: T.nilable(Integer),
      buffer_size: T.nilable(Integer),
      running_workflows: T.nilable(T::Array[T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)]),
      recent_actions: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::ScheduleActionResult)]),
      future_action_times: T.nilable(T::Array[T.nilable(Google::Protobuf::Timestamp)]),
      create_time: T.nilable(Google::Protobuf::Timestamp),
      update_time: T.nilable(Google::Protobuf::Timestamp),
      invalid_schedule_error: T.nilable(String)
    ).void
  end
  def initialize(
    action_count: 0,
    missed_catchup_window: 0,
    overlap_skipped: 0,
    buffer_dropped: 0,
    buffer_size: 0,
    running_workflows: [],
    recent_actions: [],
    future_action_times: [],
    create_time: nil,
    update_time: nil,
    invalid_schedule_error: ""
  )
  end

  # Number of actions taken so far.
  sig { returns(Integer) }
  def action_count
  end

  # Number of actions taken so far.
  sig { params(value: Integer).void }
  def action_count=(value)
  end

  # Number of actions taken so far.
  sig { void }
  def clear_action_count
  end

  # Number of times a scheduled action was skipped due to missing the catchup window.
  sig { returns(Integer) }
  def missed_catchup_window
  end

  # Number of times a scheduled action was skipped due to missing the catchup window.
  sig { params(value: Integer).void }
  def missed_catchup_window=(value)
  end

  # Number of times a scheduled action was skipped due to missing the catchup window.
  sig { void }
  def clear_missed_catchup_window
  end

  # Number of skipped actions due to overlap.
  sig { returns(Integer) }
  def overlap_skipped
  end

  # Number of skipped actions due to overlap.
  sig { params(value: Integer).void }
  def overlap_skipped=(value)
  end

  # Number of skipped actions due to overlap.
  sig { void }
  def clear_overlap_skipped
  end

  # Number of dropped actions due to buffer limit.
  sig { returns(Integer) }
  def buffer_dropped
  end

  # Number of dropped actions due to buffer limit.
  sig { params(value: Integer).void }
  def buffer_dropped=(value)
  end

  # Number of dropped actions due to buffer limit.
  sig { void }
  def clear_buffer_dropped
  end

  # Number of actions in the buffer. The buffer holds the actions that cannot
# be immediately triggered (due to the overlap policy). These actions can be a result of
# the normal schedule or a backfill.
  sig { returns(Integer) }
  def buffer_size
  end

  # Number of actions in the buffer. The buffer holds the actions that cannot
# be immediately triggered (due to the overlap policy). These actions can be a result of
# the normal schedule or a backfill.
  sig { params(value: Integer).void }
  def buffer_size=(value)
  end

  # Number of actions in the buffer. The buffer holds the actions that cannot
# be immediately triggered (due to the overlap policy). These actions can be a result of
# the normal schedule or a backfill.
  sig { void }
  def clear_buffer_size
  end

  # Currently-running workflows started by this schedule. (There might be
# more than one if the overlap policy allows overlaps.)
# Note that the run_ids in here are the original execution run ids as
# started by the schedule. If the workflows retried, did continue-as-new,
# or were reset, they might still be running but with a different run_id.
  sig { returns(T::Array[T.nilable(Temporalio::Api::Common::V1::WorkflowExecution)]) }
  def running_workflows
  end

  # Currently-running workflows started by this schedule. (There might be
# more than one if the overlap policy allows overlaps.)
# Note that the run_ids in here are the original execution run ids as
# started by the schedule. If the workflows retried, did continue-as-new,
# or were reset, they might still be running but with a different run_id.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def running_workflows=(value)
  end

  # Currently-running workflows started by this schedule. (There might be
# more than one if the overlap policy allows overlaps.)
# Note that the run_ids in here are the original execution run ids as
# started by the schedule. If the workflows retried, did continue-as-new,
# or were reset, they might still be running but with a different run_id.
  sig { void }
  def clear_running_workflows
  end

  # Most recent ten actual action times (including manual triggers).
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::ScheduleActionResult)]) }
  def recent_actions
  end

  # Most recent ten actual action times (including manual triggers).
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def recent_actions=(value)
  end

  # Most recent ten actual action times (including manual triggers).
  sig { void }
  def clear_recent_actions
  end

  # Next ten scheduled action times.
  sig { returns(T::Array[T.nilable(Google::Protobuf::Timestamp)]) }
  def future_action_times
  end

  # Next ten scheduled action times.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def future_action_times=(value)
  end

  # Next ten scheduled action times.
  sig { void }
  def clear_future_action_times
  end

  # Timestamps of schedule creation and last update.
  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def create_time
  end

  # Timestamps of schedule creation and last update.
  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def create_time=(value)
  end

  # Timestamps of schedule creation and last update.
  sig { void }
  def clear_create_time
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def update_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def update_time=(value)
  end

  sig { void }
  def clear_update_time
  end

  sig { returns(String) }
  def invalid_schedule_error
  end

  sig { params(value: String).void }
  def invalid_schedule_error=(value)
  end

  sig { void }
  def clear_invalid_schedule_error
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Schedule::V1::Schedule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::Schedule) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::Schedule).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::Schedule) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::Schedule, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      spec: T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec),
      action: T.nilable(Temporalio::Api::Schedule::V1::ScheduleAction),
      policies: T.nilable(Temporalio::Api::Schedule::V1::SchedulePolicies),
      state: T.nilable(Temporalio::Api::Schedule::V1::ScheduleState)
    ).void
  end
  def initialize(
    spec: nil,
    action: nil,
    policies: nil,
    state: nil
  )
  end

  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec)) }
  def spec
  end

  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec)).void }
  def spec=(value)
  end

  sig { void }
  def clear_spec
  end

  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::ScheduleAction)) }
  def action
  end

  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::ScheduleAction)).void }
  def action=(value)
  end

  sig { void }
  def clear_action
  end

  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::SchedulePolicies)) }
  def policies
  end

  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::SchedulePolicies)).void }
  def policies=(value)
  end

  sig { void }
  def clear_policies
  end

  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::ScheduleState)) }
  def state
  end

  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::ScheduleState)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
# that's returned in ListSchedules.
class Temporalio::Api::Schedule::V1::ScheduleListInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleListInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleListInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleListInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleListInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      spec: T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec),
      workflow_type: T.nilable(Temporalio::Api::Common::V1::WorkflowType),
      notes: T.nilable(String),
      paused: T.nilable(T::Boolean),
      recent_actions: T.nilable(T::Array[T.nilable(Temporalio::Api::Schedule::V1::ScheduleActionResult)]),
      future_action_times: T.nilable(T::Array[T.nilable(Google::Protobuf::Timestamp)])
    ).void
  end
  def initialize(
    spec: nil,
    workflow_type: nil,
    notes: "",
    paused: false,
    recent_actions: [],
    future_action_times: []
  )
  end

  # From spec:
# Some fields are dropped from this copy of spec: timezone_data
  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec)) }
  def spec
  end

  # From spec:
# Some fields are dropped from this copy of spec: timezone_data
  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::ScheduleSpec)).void }
  def spec=(value)
  end

  # From spec:
# Some fields are dropped from this copy of spec: timezone_data
  sig { void }
  def clear_spec
  end

  # From action:
# Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
# well with JSON. If action is start_workflow, this is set:
  sig { returns(T.nilable(Temporalio::Api::Common::V1::WorkflowType)) }
  def workflow_type
  end

  # From action:
# Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
# well with JSON. If action is start_workflow, this is set:
  sig { params(value: T.nilable(Temporalio::Api::Common::V1::WorkflowType)).void }
  def workflow_type=(value)
  end

  # From action:
# Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
# well with JSON. If action is start_workflow, this is set:
  sig { void }
  def clear_workflow_type
  end

  # From state:
  sig { returns(String) }
  def notes
  end

  # From state:
  sig { params(value: String).void }
  def notes=(value)
  end

  # From state:
  sig { void }
  def clear_notes
  end

  sig { returns(T::Boolean) }
  def paused
  end

  sig { params(value: T::Boolean).void }
  def paused=(value)
  end

  sig { void }
  def clear_paused
  end

  # From info (maybe fewer entries):
  sig { returns(T::Array[T.nilable(Temporalio::Api::Schedule::V1::ScheduleActionResult)]) }
  def recent_actions
  end

  # From info (maybe fewer entries):
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def recent_actions=(value)
  end

  # From info (maybe fewer entries):
  sig { void }
  def clear_recent_actions
  end

  sig { returns(T::Array[T.nilable(Google::Protobuf::Timestamp)]) }
  def future_action_times
  end

  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def future_action_times=(value)
  end

  sig { void }
  def clear_future_action_times
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# ScheduleListEntry is returned by ListSchedules.
class Temporalio::Api::Schedule::V1::ScheduleListEntry
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Schedule::V1::ScheduleListEntry) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleListEntry).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Schedule::V1::ScheduleListEntry) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Schedule::V1::ScheduleListEntry, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      schedule_id: T.nilable(String),
      memo: T.nilable(Temporalio::Api::Common::V1::Memo),
      search_attributes: T.nilable(Temporalio::Api::Common::V1::SearchAttributes),
      info: T.nilable(Temporalio::Api::Schedule::V1::ScheduleListInfo)
    ).void
  end
  def initialize(
    schedule_id: "",
    memo: nil,
    search_attributes: nil,
    info: nil
  )
  end

  sig { returns(String) }
  def schedule_id
  end

  sig { params(value: String).void }
  def schedule_id=(value)
  end

  sig { void }
  def clear_schedule_id
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::Memo)) }
  def memo
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::Memo)).void }
  def memo=(value)
  end

  sig { void }
  def clear_memo
  end

  sig { returns(T.nilable(Temporalio::Api::Common::V1::SearchAttributes)) }
  def search_attributes
  end

  sig { params(value: T.nilable(Temporalio::Api::Common::V1::SearchAttributes)).void }
  def search_attributes=(value)
  end

  sig { void }
  def clear_search_attributes
  end

  sig { returns(T.nilable(Temporalio::Api::Schedule::V1::ScheduleListInfo)) }
  def info
  end

  sig { params(value: T.nilable(Temporalio::Api::Schedule::V1::ScheduleListInfo)).void }
  def info=(value)
  end

  sig { void }
  def clear_info
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end
