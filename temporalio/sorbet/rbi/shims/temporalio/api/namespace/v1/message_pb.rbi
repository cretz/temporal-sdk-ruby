# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: temporal/api/namespace/v1/message.proto
# typed: strict

class Temporalio::Api::Namespace::V1::NamespaceInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::NamespaceInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::NamespaceInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      name: T.nilable(String),
      state: T.nilable(T.any(Symbol, String, Integer)),
      description: T.nilable(String),
      owner_email: T.nilable(String),
      data: T.nilable(T::Hash[String, String]),
      id: T.nilable(String),
      capabilities: T.nilable(Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities),
      supports_schedules: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    name: "",
    state: :NAMESPACE_STATE_UNSPECIFIED,
    description: "",
    owner_email: "",
    data: ::Google::Protobuf::Map.new(:string, :string),
    id: "",
    capabilities: nil,
    supports_schedules: false
  )
  end

  sig { returns(String) }
  def name
  end

  sig { params(value: String).void }
  def name=(value)
  end

  sig { void }
  def clear_name
  end

  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  sig { void }
  def clear_state
  end

  sig { returns(String) }
  def description
  end

  sig { params(value: String).void }
  def description=(value)
  end

  sig { void }
  def clear_description
  end

  sig { returns(String) }
  def owner_email
  end

  sig { params(value: String).void }
  def owner_email=(value)
  end

  sig { void }
  def clear_owner_email
  end

  # A key-value map for any customized purpose.
  sig { returns(T::Hash[String, String]) }
  def data
  end

  # A key-value map for any customized purpose.
  sig { params(value: ::Google::Protobuf::Map).void }
  def data=(value)
  end

  # A key-value map for any customized purpose.
  sig { void }
  def clear_data
  end

  sig { returns(String) }
  def id
  end

  sig { params(value: String).void }
  def id=(value)
  end

  sig { void }
  def clear_id
  end

  # All capabilities the namespace supports.
  sig { returns(T.nilable(Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities)) }
  def capabilities
  end

  # All capabilities the namespace supports.
  sig { params(value: T.nilable(Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities)).void }
  def capabilities=(value)
  end

  # All capabilities the namespace supports.
  sig { void }
  def clear_capabilities
  end

  # Whether scheduled workflows are supported on this namespace. This is only needed
# temporarily while the feature is experimental, so we can give it a high tag.
  sig { returns(T::Boolean) }
  def supports_schedules
  end

  # Whether scheduled workflows are supported on this namespace. This is only needed
# temporarily while the feature is experimental, so we can give it a high tag.
  sig { params(value: T::Boolean).void }
  def supports_schedules=(value)
  end

  # Whether scheduled workflows are supported on this namespace. This is only needed
# temporarily while the feature is experimental, so we can give it a high tag.
  sig { void }
  def clear_supports_schedules
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Namespace::V1::NamespaceConfig
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::NamespaceConfig) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceConfig).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::NamespaceConfig) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceConfig, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      workflow_execution_retention_ttl: T.nilable(Google::Protobuf::Duration),
      bad_binaries: T.nilable(Temporalio::Api::Namespace::V1::BadBinaries),
      history_archival_state: T.nilable(T.any(Symbol, String, Integer)),
      history_archival_uri: T.nilable(String),
      visibility_archival_state: T.nilable(T.any(Symbol, String, Integer)),
      visibility_archival_uri: T.nilable(String),
      custom_search_attribute_aliases: T.nilable(T::Hash[String, String])
    ).void
  end
  def initialize(
    workflow_execution_retention_ttl: nil,
    bad_binaries: nil,
    history_archival_state: :ARCHIVAL_STATE_UNSPECIFIED,
    history_archival_uri: "",
    visibility_archival_state: :ARCHIVAL_STATE_UNSPECIFIED,
    visibility_archival_uri: "",
    custom_search_attribute_aliases: ::Google::Protobuf::Map.new(:string, :string)
  )
  end

  sig { returns(T.nilable(Google::Protobuf::Duration)) }
  def workflow_execution_retention_ttl
  end

  sig { params(value: T.nilable(Google::Protobuf::Duration)).void }
  def workflow_execution_retention_ttl=(value)
  end

  sig { void }
  def clear_workflow_execution_retention_ttl
  end

  sig { returns(T.nilable(Temporalio::Api::Namespace::V1::BadBinaries)) }
  def bad_binaries
  end

  sig { params(value: T.nilable(Temporalio::Api::Namespace::V1::BadBinaries)).void }
  def bad_binaries=(value)
  end

  sig { void }
  def clear_bad_binaries
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { returns(T.any(Symbol, Integer)) }
  def history_archival_state
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def history_archival_state=(value)
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { void }
  def clear_history_archival_state
  end

  sig { returns(String) }
  def history_archival_uri
  end

  sig { params(value: String).void }
  def history_archival_uri=(value)
  end

  sig { void }
  def clear_history_archival_uri
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { returns(T.any(Symbol, Integer)) }
  def visibility_archival_state
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def visibility_archival_state=(value)
  end

  # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  sig { void }
  def clear_visibility_archival_state
  end

  sig { returns(String) }
  def visibility_archival_uri
  end

  sig { params(value: String).void }
  def visibility_archival_uri=(value)
  end

  sig { void }
  def clear_visibility_archival_uri
  end

  # Map from field name to alias.
  sig { returns(T::Hash[String, String]) }
  def custom_search_attribute_aliases
  end

  # Map from field name to alias.
  sig { params(value: ::Google::Protobuf::Map).void }
  def custom_search_attribute_aliases=(value)
  end

  # Map from field name to alias.
  sig { void }
  def clear_custom_search_attribute_aliases
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Namespace::V1::BadBinaries
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::BadBinaries) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::BadBinaries).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::BadBinaries) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::BadBinaries, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      binaries: T.nilable(T::Hash[String, T.nilable(Temporalio::Api::Namespace::V1::BadBinaryInfo)])
    ).void
  end
  def initialize(
    binaries: ::Google::Protobuf::Map.new(:string, :message, Temporalio::Api::Namespace::V1::BadBinaryInfo)
  )
  end

  sig { returns(T::Hash[String, T.nilable(Temporalio::Api::Namespace::V1::BadBinaryInfo)]) }
  def binaries
  end

  sig { params(value: ::Google::Protobuf::Map).void }
  def binaries=(value)
  end

  sig { void }
  def clear_binaries
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Namespace::V1::BadBinaryInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::BadBinaryInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::BadBinaryInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::BadBinaryInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::BadBinaryInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      reason: T.nilable(String),
      operator: T.nilable(String),
      create_time: T.nilable(Google::Protobuf::Timestamp)
    ).void
  end
  def initialize(
    reason: "",
    operator: "",
    create_time: nil
  )
  end

  sig { returns(String) }
  def reason
  end

  sig { params(value: String).void }
  def reason=(value)
  end

  sig { void }
  def clear_reason
  end

  sig { returns(String) }
  def operator
  end

  sig { params(value: String).void }
  def operator=(value)
  end

  sig { void }
  def clear_operator
  end

  sig { returns(T.nilable(Google::Protobuf::Timestamp)) }
  def create_time
  end

  sig { params(value: T.nilable(Google::Protobuf::Timestamp)).void }
  def create_time=(value)
  end

  sig { void }
  def clear_create_time
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Namespace::V1::UpdateNamespaceInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::UpdateNamespaceInfo) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::UpdateNamespaceInfo).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::UpdateNamespaceInfo) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::UpdateNamespaceInfo, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      description: T.nilable(String),
      owner_email: T.nilable(String),
      data: T.nilable(T::Hash[String, String]),
      state: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    description: "",
    owner_email: "",
    data: ::Google::Protobuf::Map.new(:string, :string),
    state: :NAMESPACE_STATE_UNSPECIFIED
  )
  end

  sig { returns(String) }
  def description
  end

  sig { params(value: String).void }
  def description=(value)
  end

  sig { void }
  def clear_description
  end

  sig { returns(String) }
  def owner_email
  end

  sig { params(value: String).void }
  def owner_email=(value)
  end

  sig { void }
  def clear_owner_email
  end

  # A key-value map for any customized purpose.
# If data already exists on the namespace, 
# this will merge with the existing key values.
  sig { returns(T::Hash[String, String]) }
  def data
  end

  # A key-value map for any customized purpose.
# If data already exists on the namespace, 
# this will merge with the existing key values.
  sig { params(value: ::Google::Protobuf::Map).void }
  def data=(value)
  end

  # A key-value map for any customized purpose.
# If data already exists on the namespace, 
# this will merge with the existing key values.
  sig { void }
  def clear_data
  end

  # New namespace state, server will reject if transition is not allowed.
# Allowed transitions are:
#  Registered -> [ Deleted | Deprecated | Handover ]
#  Handover -> [ Registered ]
# Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
  sig { returns(T.any(Symbol, Integer)) }
  def state
  end

  # New namespace state, server will reject if transition is not allowed.
# Allowed transitions are:
#  Registered -> [ Deleted | Deprecated | Handover ]
#  Handover -> [ Registered ]
# Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def state=(value)
  end

  # New namespace state, server will reject if transition is not allowed.
# Allowed transitions are:
#  Registered -> [ Deleted | Deprecated | Handover ]
#  Handover -> [ Registered ]
# Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
  sig { void }
  def clear_state
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

class Temporalio::Api::Namespace::V1::NamespaceFilter
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::NamespaceFilter) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceFilter).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::NamespaceFilter) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceFilter, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      include_deleted: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    include_deleted: false
  )
  end

  # By default namespaces in NAMESPACE_STATE_DELETED state are not included.
# Setting include_deleted to true will include deleted namespaces.
# Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
  sig { returns(T::Boolean) }
  def include_deleted
  end

  # By default namespaces in NAMESPACE_STATE_DELETED state are not included.
# Setting include_deleted to true will include deleted namespaces.
# Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
  sig { params(value: T::Boolean).void }
  def include_deleted=(value)
  end

  # By default namespaces in NAMESPACE_STATE_DELETED state are not included.
# Setting include_deleted to true will include deleted namespaces.
# Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
  sig { void }
  def clear_include_deleted
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end

# Namespace capability details. Should contain what features are enabled in a namespace.
class Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig { params(str: String).returns(Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities) }
  def self.decode(str)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Temporalio::Api::Namespace::V1::NamespaceInfo::Capabilities, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end

  sig do
    params(
      eager_workflow_start: T.nilable(T::Boolean),
      sync_update: T.nilable(T::Boolean),
      async_update: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    eager_workflow_start: false,
    sync_update: false,
    async_update: false
  )
  end

  # True if the namespace supports eager workflow start.
  sig { returns(T::Boolean) }
  def eager_workflow_start
  end

  # True if the namespace supports eager workflow start.
  sig { params(value: T::Boolean).void }
  def eager_workflow_start=(value)
  end

  # True if the namespace supports eager workflow start.
  sig { void }
  def clear_eager_workflow_start
  end

  # True if the namespace supports sync update
  sig { returns(T::Boolean) }
  def sync_update
  end

  # True if the namespace supports sync update
  sig { params(value: T::Boolean).void }
  def sync_update=(value)
  end

  # True if the namespace supports sync update
  sig { void }
  def clear_sync_update
  end

  # True if the namespace supports async update
  sig { returns(T::Boolean) }
  def async_update
  end

  # True if the namespace supports async update
  sig { params(value: T::Boolean).void }
  def async_update=(value)
  end

  # True if the namespace supports async update
  sig { void }
  def clear_async_update
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end
end
